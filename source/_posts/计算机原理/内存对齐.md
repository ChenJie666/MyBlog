---
title: 内存对齐
categories:
- 计算机原理
---
# 一、概念
**为什么要内存对齐？** 
- 1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 
- 2.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
## 1.1 内存物理结构
我们来了解一下内存的物理构造，一般内存的外形图片如下图：

![image.png](内存对齐.assets\10db93fa3d1441f491e0b5ff55698659.png)

一个内存是由若干个黑色的内存颗粒构成的。每一个内存颗粒叫做一个chip。每个chip内部，是由8个bank组成的。而每一个bank是一个二维平面上的矩阵。矩阵中每一个元素中都是保存了1个字节，也就是8个bit。

## 1.2 内存编址方式
### 1.2.1 说法一
![image.png](内存对齐.assets\61da3319687a4e7a8ede996ad7ccb813.png)

**原理：**如上图，每次寻址都会访问每个chip，虽然处在不同的chip，但是会共用同一个地址。这样一次访问就可以同时获取8个物理上不连续的字节，组合起来成为逻辑上连续的8个字节。

**内存对齐原因：**这样的设计提高了内存的访问效率，但是这里地址就只能是8的倍数，即内存对齐。因为内存不对齐，势必一个chip上存储了两个字节且地址不同，计算机需要两次寻址并进行组合才能得到8个连续的字节。

**补充：**
1. 64位计算机有64跟总线，可以表示2^64个存储单元的地址(一般1存储单元大小为1byte)，所以指针为了能检索所有的地址，其大小也是8byte。
2. 对齐边界位8byte

### 1.2.2 说法二
那么对于我们在应用程序中内存中地址连续的8个字节,例如0x0000-0x0007，是从位于bank上的呢？直观感觉，应该是在第一个bank上吗？ 其实不是的，程序员视角看起来连续的地址0x0000-0x0007，实际上位8个bank中的，每一个bank只保存了一个字节。在物理上，他们并不连续。下图很好地阐述了实际情况。

![image.png](内存对齐.assets\36a712564167413ab43690053b91f686.png)

内存中的8个bank是可以并行工作的。 如果你想读取址0x0000-0x0007，每个bank工作一次，拼起来就是你要的数据，IO效率会比较高。但要存在一个bank里，那这个bank只能自己干活。只能串行进行读取，需要读8次，这样速度会慢很多。


## 1.3 结论
所以，内存对齐最最底层的原因是内存的IO是以8个字节64bit为单位进行的。 对于64位数据宽度的内存，假如cpu也是64位的cpu（现在的计算机基本都是这样的），每次内存IO获取数据都是从同行同列的8个bank中各自读取一个字节拼起来的。从内存的0地址开始，0-7字节的数据可以一次IO读取出来，8-15字节的数据也可以一次读取出来。

换个例子，假如你指定要获取的是0x0001-0x0008，也是8字节，但是不是0开头的，内存需要怎么工作呢？没有好办法，内存只好先工作一次把0x0000-0x0007取出来，然后再把0x0008-0x0015取出来，把两次的结果都返回给你。 CPU和内存IO的硬件限制导致没办法一次跨在两个数据宽度中间进行IO。这样你的应用程序就会变慢，算是计算机因为你不懂内存对齐而给你的一点点惩罚。

>扩展1：事实上，编译和链接器会自动替开发者对齐内存的，尽量帮你保证一个变量不跨列寻址。但是他不能做到十分完美。
扩展2：其实在内存硬件层上，还有操作系统层。操作系统还管理了CPU的一级、二级、三级缓存，高速缓存里的Cache Line也是64字节，它是内存IO的整数倍，不会让内存IO浪费。

<br>
# 二、内存对齐实例
## 2.1 例
两个结构体如下：
```
typedef struct {
    int a;
    double b;
    short c;
}A;
```
```
typedef struct {
    int a;
    short b;
    double c;
}B;
```
分别对他们求大小，sizeof(A),sizeof(B)我们所得到的结果是不同的， 
sizeof(A)=24而sizeof(B)=16为什么会产生不一样的结果呢？ 
这是非常简单的一个例子，体现了结构体的内存对齐规则。 
在结构体中，从结构体的首地址开始，假设地址从0开始。 
对结构体A来说，a占4个字节，占从0\~3的字节，b是double类型占8个字节，占从8\~15的字节，c占两个字节，从16\~17的字节。 
对结构体B来说，a占4个字节，从0\~3，b占两个字节从4\~6；c占8个字节从8\~15。 
这就是内存对齐，对齐规则是按照成员的声明顺序，依次安排内存，其偏移量为成员大小的整数倍，0看做任何成员的整数倍，最后结构体的大小为最大成员的整数倍（所以这里的A的大小是24，而不是18）。

**具体规则如下:**
1.数据类型自身的对齐值： 对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。
2.结构体或者类的自身对齐值： 其成员中自身对齐值最大的那个值。
3.结构体的首地址必须满足结构体中边界对齐要求最为严格的数据类型所要求的首地址 
4.数据成员、结构体和类的有效对齐值： 自身对齐值和指定对齐值中小的那个值。即结构体的大小为其最宽数据类型的整数倍。
5. 系统最大对齐边界需要看平台类型，64位为8byte。

![image.png](内存对齐.assets\1dfa9c0afcd644dea1d2137b24d9f8e5.png)
如上图，如果使用int8类型，占用1byte，那么对齐到1整数倍即可。如果使用int16类型，占用2byte，那么对齐到2的整数倍，防止出现内存不对齐导致两次读取。
同理一个结构体，除了结构体成员需要内存对齐，为了保证结构体内存对齐，那么需要结构体对齐到结构体大小的整数倍。


## 2.2 面试题
```
class A 
{
  int a;
  short b;
  int c;
  char d;
};
```
```
class B
{
  double a;
  short b;
  int c;
  char d;
};
```
在32位机器上用gcc编码以上代码，求sizeof(A) , sizeof(B)分别是多少？
A 12,16    B 12,12    C 16,24    D 16,20

答案为：C
