---
title: 分布式锁的理论与实现
categories:
- SpringCloud
---
# 前言
####zookeeper实现优于redis的原因：
- 1. redis集群主节点切换时可能导致锁失效，Zookeeper内部的选举机制保证主节点切换时锁不会失效。
- 2. 为了防止主机宕机或网络断开之后的死锁，Redis没有ZK那种天然的实现方式，只能依赖设置超时时间来规避。
- 3. zk可以使用临时顺序节点来上锁，避免惊群效应。

####Redisson的特性：
- 互斥性和自解锁：使用hset (UUID+threadId, 1) 保证；
- 不会发生死锁：设置定时事件；
- 锁不能自己失效：通过看门狗功能，使用定时器判断锁失效时间，并延长事件；
- 容错性：使用红锁RedissonRedLock解决。

####Zookeeper的特性：
- 互斥性、自解锁和不发生死锁：最小的临时顺序节点拿到锁；
- 容错性：zk的选举机制；
- 锁不能自己失效：只有主动删除和结束会话才会删除节点。

<br>
# 一、基于Redis的分布式锁
## 1.1 为什么要使用分布式锁
**先看两个常见的例子：**

**例1：某服务记录关键数据X，当前值为100。A请求需要将X增加200；同时，B请求需要将X减100。**

在理想的情况下，A先读取到X=100，然后X增加200，最后写入X=300。B请求接着从读取X=300，减少100，最后写入X=200。

然而在真实情况下，如果不做任何处理，则可能会出现：A和B同时读取到X=100；A写入之前B读取到X；B比A先写入等情况。

**例2：某服务提供一组任务，A请求随机从任务组中获取一个任务；B请求随机从任务组中获取一个任务。**

在理想的情况下，A从任务组中挑选一个任务，任务组删除该任务，B从剩下的的任务中再挑一个，任务组删除该任务。

同样的，在真实情况下，如果不做任何处理，可能会出现A和B挑中了同一个任务的情况。

## 1.2 需要思考的问题
### 1.2.1 基础问题
**问题1：锁状态判断原子性无法保证**

从读取锁的状态，到判断该状态是否为被锁，需要经历两步操作。如果不能保证这两步的原子性，就可能导致不止一个请求获取到了锁，这显然是不行的。因此，我们需要保证锁状态判断的原子性。

**问题2：网络断开或主机宕机，锁状态无法清除**

假设在主机已经获取到锁的情况下，突然出现了网络断开或者主机宕机，如果不做任何处理该锁将仍然处于被锁定的状态。那么之后所有的请求都无法再成功抢占到这个锁。因此，我们需要在持有锁的主机宕机或者网络断开的时候，及时的释放掉这把锁。

**问题3：无法保证释放的是自己上锁的那把锁**

在解决了问题2的情况下再设想一下，假设持有锁的主机A在临界区遇到网络抖动导致网络断开，分布式锁及时的释放掉了这把锁。之后，另一个主机B占有了这把锁，但是此时主机A网络恢复，退出临界区时解锁。由于都是同一把锁，所以A就会将B的锁解开。此时如果有第三个主机尝试抢占这把锁，也将会成功获得。因此，我们需要在解锁时，确定自己解的这个锁正是自己锁上的。

### 1.2.2 进阶条件
如果分布式锁的实现，还能再解决上面的三个问题，那么就可以算是一个相对完整的分布式锁了。然而，在实际的系统环境中，还会对分布式锁有更高级的要求。
- 可重入：线程中的可重入，指的是外层函数获得锁之后，内层也可以获得锁，ReentrantLock和synchronized都是可重入锁；衍生到分布式环境中，一般仍然指的是线程的可重入，在绝大多数分布式环境中，都要求分布式锁是可重入的。
- 惊群效应（Herd Effect）：在分布式锁中，惊群效应指的是，在有多个请求等待获取锁的时候，一旦占有锁的线程释放之后，如果所有等待的方都同时被唤醒，尝试抢占锁。但是这样的情况会造成比较大的开销，那么在实现分布式锁的时候，应该尽量避免惊群效应的产生。
- 公平锁和非公平锁：不同的需求，可能需要不同的分布式锁。非公平锁普遍比公平锁开销小。但是业务需求如果必须要锁的竞争者按顺序获得锁，那么就需要实现公平锁。
- 阻塞锁和自旋锁：针对不同的使用场景，阻塞锁和自旋锁的效率也会有所不同。阻塞锁会有上下文切换，如果并发量比较高且临界区的操作耗时比较短，那么造成的性能开销就比较大了。但是如果临界区操作耗时比较长，一直保持自旋，也会对CPU造成更大的负荷。

**可靠的分布式锁的特征**
- 互斥性：只能有一个线程持有锁；
- 不会发生死锁：即是客户端崩溃没有释放锁，也不会造成其他线程一直拿不到锁
- 具有容错性：大部分redis节点运行正常，客户端就可以正常加解锁
- 解铃还须系铃人：加锁和解锁必须是同一个客户端；
- 锁不能自己失效：正常执行程序中，锁不能因为某些原因失效。

## 1.3 实现

### 1.3.1 自定义分布式锁
***步骤***
1. 在执行业务代码前添加上redis操作指令，通过setnx向redis中插入一条k-v值同时设置超时时间，key保持一致，value通过UUID获取唯一值。(注：setnx操作如果存在相同key，则插入失败)
2. 如果插入成功，说明没有分布式锁，则进行业务操作
3. 最后需要删除分布式锁，直接通过finally进行删除。

***伪代码***
```java
try{
  Boolean result =  redisTemplate.opsForValue().setIfAbsent(lockKey,uuid,10,TimeUnit.SECONDS);  
  if(!result){
    return "锁被其他线程占用，请稍后再试";
  }
  
  //TODO 业务代码

} finally {
  if(uuid.equals(redisTemplate.opsForValue().get(lockKey))){
    redisTemplate.delete(lockKey);
  }
}

return result;
```

***注意点***
1. 需要设置过期时间，防止锁删除失败导致进程阻塞。
2. value需要设置为不同值，避免线程一执行时间过长，导致锁过期，然后线程二放入锁但是马上被线程一删除，导致锁永久失效的情况发生。
3. 开启线程监控进程启动时间，执行到锁失效时间的1/3时，业务未执行完成，需要为锁重置过期时间。防止进程执行中锁失效问题。
4. 可以使用GETSET（先写新值，返回旧值，原子性操作，可以用于分辨是不是首次操作）操作来实现重入锁。

### 1.3.2 redisson分布式锁框架实现
![加锁流程](分布式锁的理论与实现.assets