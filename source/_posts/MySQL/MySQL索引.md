---
title: MySQL索引
categories:
- MySQL
---
# 一、 索引概念
索引是排好序的快速查找的数据结构。保存了主键和索引字段，并指向实体表的记录。
索引主要是为了快速定位数据，通过减少读取页导致的IO加快查询速度。

`如果不使用索引进行查询，不会使用行锁，而是使用表锁锁住整张表。因为行锁锁的是索引。`

**优势**
- 提高数据的检索效率（logN），降低数据库的IO成本（每一页IO一次）。
- 对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

**劣势**
- 占用空间，会存储在内容中和磁盘中。
- 对表的修改都需要修改对应的索引。


**索引结构**
![image.png](MySQL索引.assets\64cad3afe717458eac4e39f7a742fa89.png)
如果B+树有2层，最多能存放 1000×100=10,0000 条记录。
如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。
如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。
默认一页大小为16KB，那么三层索引可以存储16GB数据。

**B+Tree相对于B-Tree有几点不同：**
- 非叶子节点只存储键值信息。
- 所有叶子节点之间都有一个链指针。
- 数据记录都存放在叶子节点中。

**不使用B-Tree的原因**
- B+Tree非叶子节点只存索引key而不存data时，就可以使得非叶子节点的占用空间变少，16KB的目录页可以存储更多的目录项。所以相同数据量，**B+TREE阶数更低，深度更小，查询效率高**。
- B+Tree检索深度相同，查询数据的时间基本相同。所以**查询效率稳定**。
- B+Tree读取时可以保证连续读取的数据有序，不需要去父节点找数据。所以**排序效率高**。

**不使用Hash索引的原因**
Hash索引实质是用Hashmap结构存储，通过hash计算分配到对应桶中。
对于**精确查询，Hash索引效率高于B+Tree索引**。
但是Hash索引**不能进行范围查询**，**不支持联合索引的最左原则**（即联合索引部分索引无法使用）、**不支持ORDER BY 排序**、无法进行**模糊查询**。
这是因为Hash索引指向的数据是无序的，所以innodb中的索引使用了B+Tree存储。

<br>
## 1.1 索引类型
**索引分类**
1.普通索引index :加速查找
2.唯一索引
    主键索引：primary key ：加速查找+约束（不为空且唯一）
    唯一索引：unique：加速查找+约束 （唯一）
3.联合索引
    -primary key(id,name):联合主键索引
    -unique(id,name):联合唯一索引
    -index(id,name):联合普通索引
4.全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。
5.空间索引spatial :了解就好，几乎不用

**使用分类：**
- 单值索引：一个索引只包含单个列，一个表可以有多个单列索引。
- 唯一索引：索引列的值必须唯一，但允许有空值。
- 复合索引：一个索引包含多个列

**逻辑分类：**
- 主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候指定了主键，就会创建主键索引。
- 唯一索引：与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。
- 普通索引：这是最基本的索引，它没有任何限制。
- 组合索引：一个索引包含多个列。
- 全文索引：FULLTEXT索引用于全文搜索。只有InnoDB和 MyISAM存储引擎支持 FULLTEXT索引和仅适用于 CHAR， VARCHAR和 TEXT列。

**语法**
创建：CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));
ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length));
删除：DROP INDEX [indexName] ON table;
查看：SHOW INDEX FROM table_name\G


## 1.2 索引流程
如果没有指定主键索引，就会选一个不包含NULL的第一个唯一索引列作为主键列，并把它用作一个聚集索引。如果没有这样的索引就会使用行号生成一个聚集索引，把它当做主键。

InnoDB 只在主键索引树的叶子节点存储了具体数据。

**非主键索引：**
比如说user_name是个索引，当执行该SQL：select * from user_info where `user_name` = 'xiaoming'; InnoDB 就会建立 user_name 索引 B+树，节点里存的是 user_name 这个 KEY，叶子节点存储的数据的是主键 KEY。注意，叶子存储的是主键 KEY！拿到主键 KEY 后，InnoDB 才会去主键索引树里根据刚在 user_name 索引树找到的主键 KEY查找到对应的数据。

## 1.3 聚集索引
- **聚集索引：**聚集索引，也就是聚簇索引，叶子节点包含了完整的数据记录，也就是说，你的索引，包括你的索引所在行的其他数据，都是放在一起的。这就是聚集索引。InnoDB的主键索引，它就是聚集索引。
   - **聚簇索引的好处：**
按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io 操作。
   - **聚簇索引的限制：**
对于mysql 数据库目前只有innodb 数据引擎支持聚簇索引，而Myisam 并不支持聚簇索引。由于数据物理存储排序方式只能有一种，所以每个Mysql 的表只能有一个聚簇索引。一般情况下就是该表的主键。
- **非聚集索引：**索引文件和数据文件是分离的。如MyISAM引擎，叶子节点的data存的是索引所在行的磁盘空间地址，它的主键索引跟数据是分开存储的。细分一下非聚集索引，分成普通索引，唯一索引，全文索引。
**非聚集索引的二次查询问题：**非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，因此如果使用非聚集索引查询，而查询列中包含了该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。
**如何解决非聚集索引的二次查询问题：**使用复合索引，建立两列以上的索引(覆盖索引)，即可查询复合索引里的列的数据而不需要进行回表二次查询，如index(col1, col2)，执行下面的语句**select col1, col2 from t1 where col1 = '213';**



| 动作描述           | 使用聚集索引 | 使用非聚集索引 |
| ------------------ | ------------ | -------------- |
| 列经常被分组排序   | 应           | 应             |
| 返回某范围内的数据 | 应           | 不应           |
| 一个或极少不同值   | 不应         | 不应           |
| 小数目的不同值     | 应           | 不应           |
| 大数目的不同值     | 不应         | 应             |
| 频繁更新的列       | 不应         | 应             |
| 外键列             | 应           | 应             |
| 主键列             | 应           | 应             |
| 频繁修改索引列     | 不应         | 应             |




<br>
#### 问题
**1. 为什么建议InnoDB表必须建主键，并且推荐使用整型 自增主键？**
InnoDB底层要靠主键，来组织数据表数据，通俗点，就是要靠主键，来维护这个B+树。
`以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键`。
它会看我们的每一列是否有唯一的这些数据列，如果有，就用这一列来组织树结构。
假如，连这个唯一的数据列也没有，那么，它会建一个唯一的隐藏列row_id，来维护B+树。
Mysql本身资源就很紧张了，所以，这些我们能做的一定要尽量做，尽量建立主键.

**2. 为什么要保证是整型且自增呢？**
因为，mysql插入以及维护的时候，是有序的。
在查找数据的时候，会牵扯到很多比较，整型比大小，相比于uuid之类的字符串比大小要快的多。另外，整型相比于uuid类似的字符串，会更加节省空间。
假如，不是自增插入，由于B+树要维护索引的有序性，如果插入到之前页的数据，但是这些页16KB已经满了，就会涉及到B+树的分裂，影响性能。
如果，都是用自增的，每次都是往现有数据的后面插入数据。

**3. B+Tree为什么可以提高范围查询性能？**
首先，Mysql是一个排好序的数据结构，叶子节点都有一个双向指针进行连接。
假如，我们要查找col>20这些数据，我们可以先查col=20对应叶子节点的位置，定位到以后，由于都是排好序的，只需要依次往后遍历即可查出所有。
对于col<20，也是一样，因为叶子节点存有向前的指针，也是可以很方便查出所有数据。


<br>
## 1.4 索引结构
**B+Tree索引：**

**Hash索引：**哈希索引基于hash表实现，类似于Java中的HashMap，通过计算key的hash值映射对应的value，在不发生hash冲突的情况下时间复杂度为常数级别，MySQL的hash索引会对所有的索引列计算一个hash码，由于hash的索引的特点，它的缺点也显而易见，只有精确匹配索引所有列的查询才有效，hash索引数据也并不是按照索引值顺序存储的，所以也无无法用于排序，只支持等值查询，不支持范围查询。他是Memory引擎的默认索引类型，也是Memory引擎速度快的原因之一。

**full-text全文索引：**这是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值，全文索引更类似于搜索引擎做的事情，实际生产中我们一般不会使用MySQL来做类似搜索引擎的工作。
要做搜索的话一般都是使用专业的搜索相关开源工具，从最早的solr到现在的Elasticsearch（主要通过倒排索引，分词等来实现），它们的性能更好，功能也更加强大。

**R-Tree索引：**



<br>
## 二、.索引原理
### 2.1 b+树的查找过程
如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

**1. 索引字段要尽量的小**：通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。
**2. 索引的最左匹配特性（即从左往右匹配）**：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

<br>
### 2.2 为什么选择b+树
1. 因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；
2. b+树适合范围查询；b树存在回旋查找问题，数据之间无法做到地址连续，局部性原理无法适用。
3. 深度不同也会导致查询速度不同，导致响应时间不稳定。

![主键索引图.png](MySQL索引.assetsff4064d4fd1414990f462af86b9a1cd.png)

![复合索引图](MySQL索引.assets36465a94cff4774ac1771624308fd90.png)


### 2.3 计算多层数据能存储的数据量
#### 两层B+树存储18720行数据（2万条）
如果默认一行数据为1kB，一页为16kB，主键为bigint型8Byte，指针占用6Byte，非叶子节点存储 主键+指针。
那么一页可以保存的页面索引为16*1024/14=1170页，总共可以保存1170*16=18720行。

#### 三层B+树存储18720*1170=21902400行数据（2千万+条）
