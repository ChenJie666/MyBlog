---
title: Https原理和数字证书
categories:
- 系统安全
---
# 一、网络传输方式
### 方式一：明文传输
被拦截直接泄露信息

### 方式二：对称加密
服务器维护秘钥，客户端向服务器索要秘钥，客户端通过秘钥加密解密信息，服务器也通过秘钥加密解密信息。
产生问题：①如果每个服务器只有维护一个秘钥，那么黑客也可以拿到秘钥拦截信息并解密。②如果服务器对每个客户端都维护一个秘钥，那么服务器存储和效率产生问题。

### 方式三：非对称加密
服务器维护一对公私钥，客户端向服务器索要公钥，客户端通过公钥加密信息，服务器通过私钥解密信息；但是服务器向客户端发送信息会产生问题，服务端通过私钥加密，客户端通过公钥解密信息，那么黑客向服务器索要公钥然后拦截服务器的信息并用公钥解密，导致信息泄露。

### 方式四：非对称加密+对称加密
服务器维护一对公私钥，客户端向服务器索要公钥，然后随机生成一串数字，用公钥加密作为新秘钥，后续通讯通过该秘钥进行对称加密。保证了秘钥的唯一性。

**产生问题：中间人攻击**
黑客拦截用户请求并返回黑客的公钥，然后与客户端进行通讯；同时向服务器发送请求，将客户端的请求信息篡改后发送到服务器，造成客户损失。

<br>
# 二、数字证书
为了解决中间人攻击，使用数字证书来传递服务端的公钥。保证客户端获取到的公钥是客户端想要访问的服务端的公钥，而不是中间人的公钥。

## 2.1 CA签名证书

**如何保证公钥是目标服务器的公钥呢？**
将个人信息和公钥发送给权威公正的证书颁发机构(简称CA机构)，CA机构核实身份后颁发一个数字证书，证书中主要包含了身份信息和公钥，将证书拥有者和公钥绑定。
这样就能确保客户端拿到的是服务端的公钥，而不是中间人的公钥，防止了中间人攻击。

**CA机构是如何保证该证书不会被伪造的呢？**
因为该证书是通过CA机构数字签名的，CA机构自己也有一套公钥pk和私钥sk，在颁发证书时已经对该证书使用私钥sk进行了数字签名并将签名信息放到证书中。同时CA的根证书会预先安装在电脑或手机系统中，这样杜绝了CA的根证书被伪造的可能，同时可以通过根证书验证数字证书中的签名，保证证书是经过CA认证的且证书所有者信息真实。

**数字证书颁发过程**
1. 用户首先产生自己的密钥对，
2. 将公共密钥（公钥）及部分个人身份信息传送给认证中心
3. 认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息

**认证流程**
1. 服务器生成一对密钥，私钥自己留着，公钥交给数字证书认证机构（CA）
2. CA进行审核，并用CA自己的私钥对服务器提供的公钥进行签名生成数字证书
3. 将生成的数字证书部署到web服务器
4. client在https建立连接时，需要先从服务器获取数字证书，在本机找到数字证书的签发机构的CA的公钥（根证书）对数字证书进行验证，比对一致，说明该数字证书确实是CA颁发的（得此结论有一个前提就是：客户端的CA公钥确实是CA的公钥，即该CA的公钥与CA对服务器提供的公钥进行签名的私钥确实是一对。），而CA又作为权威机构保证该公钥的确是服务器端提供的，从而可以确认该证书中的公钥确实是合法服务器端提供的。

为保证第4步中提到的前提条件，CA的公钥必须要安全地转交给客户端（CA根证书必须先安装在客户端），因此，CA的公钥一般来说由浏览器开发商内置在浏览器或操作系统的内部。于是，该前提条件在各种信任机制上，基本保证成立。

<br>
**CA证书的组成**
- 版本
- 序列号
- 签名算法
- 颁发者
- 有效期
- 主题：证书所有者的名称
- 公钥信息：对外公开的公钥
- 指纹及指纹算法
- 签名
>◆Issuer (证书的发布机构)
指出是什么机构发布的这个证书，也就是指明这个证书是哪个公司创建的(只是创建证书，不是指证书的使用者)。对于上面的这个证书来说，就是指"SecureTrust CA"这个机构。
◆Valid from , Valid to (证书的有效期)
也就是证书的有效时间，或者说证书的使用期限。 过了有效期限，证书就会作废，不能使用了。
◆Public key (公钥)
公钥是用来对消息进行加密的
◆Subject (主题)
这个证书是发布给谁的，或者说证书的所有者，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等。 
◆Signature algorithm (签名所使用的算法)
就是指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥，根据这个算法对指纹进行解密。指纹的加密结果就是数字签名。
◆Thumbprint, Thumbprint algorithm (指纹以及指纹算法)
这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。 注意，这个指纹会使用"CA"证书机构的私钥用签名算法(Signature algorithm)加密后和证书放在一起。


## 2.2 自签名证书
服务器端使用公钥和服务器信息生成证书，并生成用于证书签名的公钥pk和私钥sk，使用哈希算法获取指纹并对指纹进行签名然后放到证书中，这样生成了自签名证书。

因为该证书不是CA颁发的，签名使用的不是CA的私钥，所以无法通过客户端内置的根证书进行解密，所以浏览器会提示不安全。
可以点击继续访问，忽略证书的有效性验证，直接使用证书中的公钥进行通讯，这样就可能被中间人攻击。


<br>
# 三、详细流程

![image.png](Https原理和数字证书.assets679837072be49bbb25d8b0abf115824.png)

1. 客户端向一个需要https访问的网站发起请求。
2. 服务器将证书发送给客户端进行校验。证书里面包含了其公钥。这里要特别说一下客户端到底 如何来校验对方发过来的数字证书是否有效。
>1.  首先在本地电脑寻找是否有这个服务器证书上的ca机构的根证书。如果有继续下一步，如果没有弹出警告。
>2.  使用`ca机构根证书的公钥对服务器证书的指纹和指纹算法进行解密`。
>3.  得到指纹算法之后，拿着这个指纹算法对服务器证书的摘要进行计算得到指纹。
>4.  将计算出的指纹和从服务器证书中解密出的指纹对比看是否一样如果一样则通过认证。

3. 校验成功之后，客户端会生成一个随机串然后使用服务器证书的公钥进行加密之后发送给服务器。
4. 服务器通过使用自己的私钥解密得到这个随机值。
5. 服务器从此开始使用这个随机值进行对称加密开始和客户端进行通信。
6. 客户端拿到值用对称加密方式 使用随机值进行解密。


**为什么不一直使用非对称进行加密，而是在类似握手之后开始使用对称加密算法进行https通信？**
非对称加密的消耗和所需的计算以及时间远比对称加密消耗要大，所以在握手和认证之后，服务器和客户端就开始按照约定的随机串，对后续的数据传输进行加密。

**双向验证**
上述是客户端通过服务端的证书完成对服务端身份的验证。Https同样支持身份的双向验证，即服务端同样可以验证客户端身份是否合法。
需要在服务端维护一个库truststore，将可信的证书放到库中，这样就可以接受客户端发来的证书并进行校验，不在证书库中的证书就是不可信的，拒绝服务。

<!--
**https请求实例**
①C -> S   支持的SSL版本、非对称加密算法、随机数1
②S -> C   使用的SSL版本、对称加密算法、随机数2
③C 认证证书
④C -> S   随机数3、将①②中的数据用hash算法如MD5进行散列加密
⑤S   验证客户端传输的散列值是否等于服务器计算的得到的散列值 => 将随机数1、随机数2、随机数3按某种算法进行计算
⑥S -> C  hash(①②④) 值
⑦C   计算hash(①②④)验证是否等于服务器传输的散列值 => 将随机数1、随机数2、随机数3按某种算法进行计算，将这个随机数作为对称加密的秘钥。
-->


![image.png](Https原理和数字证书.assets\1cc859a5cbe04d898240ea2d906b5144.png)

***三大作用***
- 认证：确认签署人身份
- 防止抵赖：不能反悔
- 防篡改：文件完整性


***http三次握手和四次挥手***
![image.png](Https原理和数字证书.assets\3c2500c1a40a4afca428fe417d706f23.png)

![image.png](Https原理和数字证书.assets\100450d95eae44d4a9f2a1a88285e29b.png)

![image.png](Https原理和数字证书.assets\993e159641d74386b0543908d5485ee3.png)


# 四、总结：
HTTPS=非对称加密+对称加密+HASH+CA
CA认证+请求服务器公钥=生成对称加密key。最后用对称加密通信。

#https申请证书并部署到网站流程

1、生成一对秘钥，设公钥为pubk1，私钥为prik1
2、假设发布的网站地址为https://www.example.com
3、生成一个CSR文件（Cerificate Signing Request），该文件内容包括: pubk1，网站地址，以及营业执照等信息，然后将该文件发给CA机构
4、CA机构收到CSR文件后，进行审核，主要检查网站地址的拥有者是否是证书的申请者
5、审核通过后，CA机构生成一对秘钥，假设采用ECDSA签名算法，公钥为pubk2，私钥为prik2。用prik2对CSR文件进行签名得到签名值sigVal，将sigVal附在CSR文件后面形成证书文件caFile，caFile中还要添加CA机构的信息，如: 签名算法，CA机构名称等
6、将证书文件caFile放到网站服务器对应目录下

====================

![image](Https原理和数字证书.assets\6e6e352751814c608679ed65a8e4f43c.png)

====================

**浏览器验证证书流程：**

1、浏览器向服务器发请求https://www.example.com
2、服务器将caFile和pubkey1(实际上就是申请证书流程中生成的一对秘钥中的公钥pubk1)发给浏览器
3、浏览器收到caFile文件进行分析，知道了签名算法；拿到CA机构名称后，由于浏览器中内置了该CA机构的根证书，所以知道pubk2；还知道caFile文件中的签名值sigVal以及原文（caFile的一部分，这部分在申请证书流程中称为CSR文件）知道这四个条件，就可以验证签名了，若验证签名成功则进入第4步。
4、接下来浏览器校验证书申请者的身份，从caFile中取出pubk1和网站地址w1。如果w1和https://www.example.com一摸一样，而且pubk1与连接成功后服务器发下来的公钥pubkey1相等，则说明浏览器连接的https://www.example.com没问题，而且没有受到中间人攻击
5、一旦服务器校验成功，接下来就是进行秘钥协商，这个协商成功后的秘钥就是真正用来加密业务数据的秘钥

<br>
# 参考
https://www.bilibili.com/video/BV18N411X7ty?from=search&seid=14864398693156546079

https://www.bilibili.com/video/BV1w4411m7GL?from=search&seid=2292224744365248502
