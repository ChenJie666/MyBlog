---
title: 布隆过滤器与布谷鸟过滤器
categories:
- 高并发
---
# 一、布隆过滤器
## 1.1 原理
### 1.1.1 布隆过滤器基础版
原理就是一个对一个key进行k个hash算法获取k个值，在比特数组中将这k个值散列后设定为1，然后查的时候如果特定的这几个位置都为1，那么布隆过滤器判断该key存在。

布隆过滤器可能会误判，如果它说不存在那肯定不存在，如果它说存在，那数据有可能实际不存在；

Redis的bitmap只支持2^32大小，对应到内存也就是512MB，误判率万分之一，可以放下2亿左右的数据，性能高，空间占用率及小，省去了大量无效的数据库连接。



![image.png](布隆过滤器与布谷鸟过滤器.assets\8fb33c079b954d2384746c7c157d20b2.png)

存入过程： 通过三个hash函数计算出三个哈希值，然后将三个值映射到数组中将0改成1。
查询过程：通过三个hash函数计算出查询数据的哈希值，然后检查布隆过滤器对应位置上的值是否为1，如果有一个不为1表示该值不存在，如果都为1表示该值可能存在。（查询时间复杂度为O(k)，k为哈希函数个数）
删除过程：不能进行删除，因为会删除掉其他数据。
更新过程：也不能进行更新。

### 1.1.2 布隆过滤器增强版
为了解决上面布隆过滤器的问题,出现了一个增强版的布隆过滤器(Counting Bloom Filter),这个过滤器的思路是将布隆过滤器的bitmap更换成数组,当数组某位置被映射一次时就+1,当删除时就-1,这样就避免了普通布隆过滤器删除数据后需要重新计算其余数据包Hash的问题,但是依旧没法避免误判。

![image.png](布隆过滤器与布谷鸟过滤器.assets