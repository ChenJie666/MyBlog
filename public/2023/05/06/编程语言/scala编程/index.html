<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>scala编程 | Hexo</title><meta name="author" content="CJ"><meta name="copyright" content="CJ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="伴生对象中可以写静态方法，但是底层并不是通过静态方法实现的。而是通过饿汉模式创建单例，通过这个单例对象进行方法的调用，实现了静态方法的功能。 只有伴生类，那么编译之后只会生成一个编译文件。只有伴生对象，那么编译之后会同时生成两个编译文件。   ![伴生类编译文件](scala编程.assets86c7bb7623402baa75f9e5412f7d3c.png) ![伴生对象编译文件](sc">
<meta property="og:type" content="article">
<meta property="og:title" content="scala编程">
<meta property="og:url" content="http://example.com/2023/05/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/scala%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="伴生对象中可以写静态方法，但是底层并不是通过静态方法实现的。而是通过饿汉模式创建单例，通过这个单例对象进行方法的调用，实现了静态方法的功能。 只有伴生类，那么编译之后只会生成一个编译文件。只有伴生对象，那么编译之后会同时生成两个编译文件。   ![伴生类编译文件](scala编程.assets86c7bb7623402baa75f9e5412f7d3c.png) ![伴生对象编译文件](sc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-06T05:31:21.079Z">
<meta property="article:modified_time" content="2023-05-06T05:31:21.079Z">
<meta property="article:author" content="CJ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/scala%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'scala编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-06 13:31:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">419</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">scala编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-06T05:31:21.079Z" title="发表于 2023-05-06 13:31:21">2023-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-06T05:31:21.079Z" title="更新于 2023-05-06 13:31:21">2023-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="scala编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<ol>
<li>伴生对象中可以写静态方法，但是底层并不是通过静态方法实现的。而是通过饿汉模式创建单例，通过这个单例对象进行方法的调用，实现了静态方法的功能。</li>
<li>只有伴生类，那么编译之后只会生成一个编译文件。只有伴生对象，那么编译之后会同时生成两个编译文件。</li>
</ol>
</blockquote>
<p>![伴生类编译文件](scala编程.assets86c7bb7623402baa75f9e5412f7d3c.png)</p>
<p>![伴生对象编译文件](scala编程.assets68afa77ce4f457d900b44fb54235a63.png)</p>
<br>
<br>
统计相同单词的数量：

<p>方式一：将字符串 * 5，然后再切割</p>
<p>方式二：将每个单词的数量以元组形式存放，再统计</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Exam22</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> lineList = <span class="type">List</span>((<span class="string">&quot;Hadoop Hbase Hive&quot;</span>,<span class="number">5</span>), (<span class="string">&quot;Hadoop Kafka Hive&quot;</span>,<span class="number">4</span>), (<span class="string">&quot;Kafka Hive&quot;</span>,<span class="number">3</span>), (<span class="string">&quot;Hive&quot;</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> tuples: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = lineList.flatMap &#123;</span><br><span class="line">      <span class="keyword">case</span> (sentence, count) =&gt; sentence.split(<span class="string">&quot; &quot;</span>).map &#123;</span><br><span class="line">        word =&gt; (word, count) <span class="comment">//将一个数组用map方法之后返回还是一个数组，所以符合flatMap的返回值可迭代要求</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> tuplesH: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = tuples.filter &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, count) =&gt; word.contains(<span class="string">&quot;H&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> stringToTuples: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = tuplesH.groupBy &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, count) =&gt; word</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> stringToInts: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">Int</span>]] = stringToTuples.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (word,list) =&gt; (word,list.map&#123;</span><br><span class="line">        <span class="keyword">case</span> (word,count) =&gt; count</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(stringToInts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stringToInt: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = stringToInts.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt; (word, list.sum)</span><br><span class="line">    &#125;</span><br><span class="line">    println(stringToInt)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    val wordSort: List[(String, Int)] = stringToInt.toList.sortBy &#123;</span></span><br><span class="line"><span class="comment">//      case (word, count) =&gt; count</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    println(wordSort)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    println(wordSort.takeRight(2))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordSort: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = stringToInt.toList.sortWith &#123;</span><br><span class="line">      <span class="keyword">case</span> ((s1, c1), (s2, c2)) =&gt; c1 &gt; c2</span><br><span class="line">    &#125;</span><br><span class="line">    println(wordSort.take(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> <strong>_  的用法：①包中所有类②系统默认初始化③将函数不执行返回④参数占位符⑤隐藏导入的类⑥标识符⑦绝对路径</strong>⑧case _ 不管什么值都匹配⑨case _:BigInt &#x3D;&gt;…  当后面不用该变量，不关心变量时，可以用 _ 代替。</p>
<p><strong>[] 的用法：①protected[包名]②泛型 classOf[] , inInstanceOf[] asInstanceOf[] ，Array[]③实现特质中方法时指向类  super[Operate].insert( )</strong></p>
<p>![1563934859730](scala.assets&#x2F;1563934859730.png</p>
<p><img src="F:/Typora/图片/1563934859730.png" alt="1563934859730"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">枚举类：</span><br><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter01</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.scala.chapter01</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="type">Color</span>.red)</span><br><span class="line">    <span class="type">Color</span>.printcolor</span><br><span class="line">    <span class="keyword">val</span> color = <span class="keyword">new</span> <span class="type">Color</span></span><br><span class="line">    println(color.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">  <span class="type">Color</span>.printcolor</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> red: chapter01.<span class="type">Color</span>.<span class="type">Value</span> = <span class="type">Value</span>(<span class="number">1</span>,<span class="string">&quot;red&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> blue = <span class="type">Value</span>(<span class="number">2</span>,<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printcolor</span> </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;I&#x27;m &quot;</span> + blue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">小朋友玩游戏：</span><br><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter01</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ChildPalyGame</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;	<span class="comment">//此处可以删去main方法，让伴生对象继承App特质，也可以									正常执行。好处是main方法会执行主方法外的可执行语言，这样更加清晰。</span></span><br><span class="line">    <span class="type">Child</span>.<span class="type">JoinGame</span>(<span class="type">Child</span>(<span class="string">&quot;zhangsan&quot;</span>))</span><br><span class="line">    <span class="type">Child</span>.<span class="type">JoinGame</span>(<span class="type">Child</span>(<span class="string">&quot;lisi&quot;</span>))</span><br><span class="line">    <span class="type">Child</span>.total</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">var name : <span class="type">String</span></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name:<span class="type">String</span>,i:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>(name:<span class="type">String</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;123124&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Child</span> = <span class="keyword">new</span> <span class="type">Child</span>(name,<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> totalChild = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">JoinGame</span></span>(child : <span class="type">Child</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(child.name + <span class="string">&quot; join the game&quot;</span>)</span><br><span class="line">    totalChild += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">total</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">&quot;total &quot;</span> + totalChild + <span class="string">&quot; playing game&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;afasdf&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译后的反编译源码：</span><br><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildPalyGame</span></span></span><br><span class="line">&#123;</span><br><span class="line">  public static void main(<span class="type">String</span>[] paramArrayOfString)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">ChildPalyGame</span>..<span class="type">MODULE</span>$.main(paramArrayOfString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildPalyGame$</span></span></span><br><span class="line">&#123;</span><br><span class="line">  public static <span class="keyword">final</span>  <span class="type">MODULE</span>$ = <span class="keyword">new</span> ();</span><br><span class="line"></span><br><span class="line">  public void main(<span class="type">String</span>[] args) &#123; <span class="type">Child</span>..<span class="type">MODULE</span>$.<span class="type">JoinGame</span>(<span class="type">Child</span>..<span class="type">MODULE</span>$.apply(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">    <span class="type">Child</span>..<span class="type">MODULE</span>$.<span class="type">JoinGame</span>(<span class="type">Child</span>..<span class="type">MODULE</span>$.apply(<span class="string">&quot;lisi&quot;</span>));</span><br><span class="line">    <span class="type">Child</span>..<span class="type">MODULE</span>$.total();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Child</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> name;		<span class="comment">//属性都是私有化的，通过对象修改或读取属性是通过set/get方法实现的</span></span><br><span class="line"></span><br><span class="line">  public static void total()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Child</span>..<span class="type">MODULE</span>$.total();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void <span class="type">JoinGame</span>(<span class="type">Child</span> paramChild)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Child</span>..<span class="type">MODULE</span>$.<span class="type">JoinGame</span>(paramChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void totalChild_$eq(int paramInt)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Child</span>..<span class="type">MODULE</span>$.totalChild_$eq(paramInt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static int totalChild()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Child</span>..<span class="type">MODULE</span>$.totalChild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static <span class="type">Child</span> apply(<span class="type">String</span> paramString)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Child</span>..<span class="type">MODULE</span>$.apply(paramString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="type">String</span> name()&#123;  <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125; 				<span class="comment">//属性的get方法</span></span><br><span class="line">  public void name_$eq(<span class="type">String</span> x$<span class="number">1</span>) &#123; <span class="keyword">this</span>.name = x$<span class="number">1</span>; &#125; 	<span class="comment">//属性的set方法</span></span><br><span class="line">  public <span class="type">Child</span>(<span class="type">String</span> name) &#123; <span class="type">Predef</span>..<span class="type">MODULE</span>$.println(<span class="string">&quot;123124&quot;</span>) &#125; 	<span class="comment">//主构造方法</span></span><br><span class="line">  public <span class="type">Child</span>(<span class="type">String</span> name, int i) &#123; <span class="keyword">this</span>(name); &#125;					<span class="comment">//辅构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Child$</span></span></span><br><span class="line">&#123;</span><br><span class="line">  public static <span class="keyword">final</span>  <span class="type">MODULE</span>$ = <span class="keyword">new</span> ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static int totalChild = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Predef</span>..<span class="type">MODULE</span>$.println(<span class="string">&quot;afasdf&quot;</span>); &#125; </span><br><span class="line">  public <span class="type">Child</span> apply(<span class="type">String</span> name) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Child</span>(name, <span class="number">1</span>); &#125; </span><br><span class="line">  public int totalChild() &#123; <span class="keyword">return</span> totalChild; &#125; </span><br><span class="line">  public void totalChild_$eq(int x$<span class="number">1</span>) &#123; totalChild = x$<span class="number">1</span>; &#125; </span><br><span class="line">  public void <span class="type">JoinGame</span>(<span class="type">Child</span> child) &#123;</span><br><span class="line">    <span class="type">Predef</span>..<span class="type">MODULE</span>$.println(<span class="number">14</span> + child.name() + <span class="string">&quot; join the game&quot;</span>);</span><br><span class="line">    totalChild_$eq(totalChild() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  public void total() &#123;</span><br><span class="line">    <span class="type">Predef</span>..<span class="type">MODULE</span>$.println(<span class="number">19</span> + <span class="string">&quot;total &quot;</span> + totalChild() + <span class="string">&quot; playing game&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>scala中，将静态的属性和方法写在伴生对象中，将非静态的属性和方法写在伴生类中。伴生对象在编译后的类中会生成一个静态的自身对象，当我们以静态的方式访问其中的属性和方法时，编译后会通过这个唯一的静态对象调用类中的属性和方法来模拟java中的静态属性和方法。

因为在底层编译时，object伴生对象也是一个类，将类中的可执行语句都放入到静态代码块中，所以在执行伴生对象的主方法时，会执行主方法外的可执行语句；当加载类时，就会先运行静态代码块中的代码。而伴生类，会将类中的可执行语言放入到主构造器中，所以scala规定必须要通过主构造器创建对象。
</code></pre>
<p>当把一个计算结果赋值给一个变量，则编译器会进行类型转化及判断。</p>
<p>当把一个字面量赋值给一个变量，则编译器会进行范围的判定。</p>
<p>var a : short &#x3D; 50 不用类型转换<br>var b : float &#x3D; 50.0f 需要指定类型<br>var c : short &#x3D; ‘a’ + 1 不会报错<br>var d : short &#x3D; 10 + 10 不会报错，再编译时会自动相加，编译后只有20，和直接写20的效果一样。如果有变量则会转成int型。</p>
<p>nothing为什么可以返回异常对象，nothing类不是底层类么？</p>
<p>scala基本原则：至简原则</p>
<p>1.使用object关键字声明</p>
<pre><code>如果使用object声明类，可以编译出两个类，一个是当前类，另外一个是当前类的一个辅助类，执行时，辅助类可以直接构建对象使用（伴生对象），为了模拟静态语法。
</code></pre>
<p>2.声明main方法</p>
<pre><code>2.1必须使用def关键字（definded）声明

2.2Scala中没有public关键字，默认访问权限就是public

2.3不需要使用static关键字声明，因为Scala是完全面向对象的语言，所以没有静态语法。

2.4 用Unit类代替关键字void

2.5scala中参数命名为   参数名 ： 参数类型

因为java是强类型语言，一定要加类型；而scala认为类型不那么重要，所以参数类型和返回值类型都放后面
</code></pre>
<p>3.打印字符串</p>
<pre><code>java：  System.out.println(）

scala： println()       predef预先编译好的功能，println就是其中之一，最终会调用java的IO流。11:40



println(raw&quot;xxxx
</code></pre>
<p>xxx”)	<br>不换行，以字符串输出</p>
<pre><code>println(&quot;&quot;&quot;xxx

        xxx

        xxx

        &quot;&quot;&quot;)		以给定的格式打印
</code></pre>
<p>println（f”age &#x3D; $age%.2f”）  f表示格式化，将$age格式化输出 </p>
<p>println(“ “ * i )  	输出i个空格 ,通过这种表达式，可以只用一个循环就打印出三角形。</p>
<p>println(s”$id,$name”)</p>
<p>javap？？javap是jdk自带的反解析工具，可以将javap指令加入到idea中，查看java字节码的反编译码。</p>
<p>javadoc指令生成API文档？通过javadoc 文件名.java，可以提取代码中的注释生成开发文档。</p>
<p>半角空格？半角占一个字节，全角占两个字节，trim去不了全角空格，可以用replace方法将全角空格换成半角空格再用trim去除。</p>
<p>15：00 改变String类中的final修饰的char数组（用反射）</p>
<p>![捕获](scala.assets&#x2F;捕获.PNG</p>
<p><img src="F:/Typora/图片/捕获.PNG" alt="捕获"></p>
<pre><code>15:37伴生对象？object类就是一个伴生对象，编译后会生成一个伴生类对象，由主函数调用。可以在伴生类中声明属性。val相当于给变量加了一个final修饰，但是编译后只有属性变量有final，因为局部变量不能用final修饰。



对于多态的类有多个重载方法，在编译时会选择重载方法，根据的是父类的类型选择重载方法，而不是子类对象的类型
</code></pre>
<p>java的object类是any的子类，anyref的父类。</p>
<p>String s &#x3D; “a” + “b” + “c”  只创建一个常量字符串”abc”，在编译的时候直接编译为“abc”，所以运行时只生成“abc”</p>
<p>16:31为什么变量相加会自动转成int类型？？底层指令不够，因为用ASCII码作为指令集（255），所以为了节省指令集空间，没有short和byte的运算指令。所以只能作int运算操作。</p>
<p>scala中所有数字也都是对象，10+10实际为10.+（10）    1 to 3 实际为1.to(3)，to方法可以指定步长1.to(10,2)步长为2。但是一般写成i &lt;- Range(1,10,2)。</p>
<p>9:20多态的动态绑定只对方法进行绑定，如果有重载的方法，调用方法时指向<strong>对象</strong>的实际的内存，如果对象中没有重写该方法，则指向父类的实际内存，成员变量为指向的内存中的值。如下图中，将注释的部分放开，运行得到的结果为30；注释之后得到的结果为20.</p>
<p><img src="F:/Typora/图片/动态绑定机制.PNG" alt="动态绑定机制"></p>
<p>10:00</p>
<p>i&#x3D;i++的字节码反编译码：即用到临时变量存储i的值，i增加1作为i的值。</p>
<p><img src="F:/Typora/图片/捕获3.PNG" alt="捕获3"></p>
<p> i&#x3D;i++的底层字节码实现：</p>
<pre><code>![捕获2](F:/Typora/图片/捕获2.PNG)	常量表中有两个常量args和i，分别占用了1号和2号slot槽位。i=i++ 底层字节码实现，先将i=10压入栈顶，然后将i的值存储到1号槽位，再将1号槽的值加载到栈顶，然后对1号槽位的值自增1。然后进行赋值操作，将栈顶的i=10再次存储到1号槽位。所以最终1号槽位的变量i的值为10；
</code></pre>
<p>10:32 BigDecimal（2.1）.&#x2F;3 &#x3D;&#x3D; 0.7	直接用浮点数2.1运算会损失精度，结果不等于0.7；所以先转成大数（字符串），再调用大数对象的方法进行计算。</p>
<p>一元运算符不提升数据类型</p>
<p>10:48</p>
<p>&amp;用于计算哈希表的slot号（map中和redis的slot计算都会用到），将2^n-1，然后与上哈希值，得到slot号。</p>
<p>当要求的长度是2^n时，用$；当不能保证长度是2^n时，只能取模。所以kafka的分区用取模来计算，因为不能保证分区数为2^n。</p>
<p>15:50？？ 调用一个为空对象的<strong>成员属性或成员方法</strong>，会发生<strong>空指针异常</strong>（即只有对象调用成员属性或成员方法是会发生空指针异常）。</p>
<p>16:17 面向对象编程	对于类的共有的属性，需要将其设为静态属性和方法。</p>
<p>将类中声明的函数称为方法，所以方法有重载和重写的概念。</p>
<p>函数没有重写和重载的概念。</p>
<p>统一访问原则，访问变量和访问函数形式统一。</p>
<p>如果函数声明返回值类型为Unit，那么函数体中的return操作不起作用。</p>
<p>9:15</p>
<p>匿名函数：()-&gt;{println(“xxx”)}	</p>
<p>val f9 &#x3D; ()&#x3D;&gt;{println(“yyy”)}	调用函数f9() ,括号不能省略。</p>
<p>val f9 &#x3D; (i:Int)&#x3D;&gt;{println(“yyy”)}</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">object</span> <span class="title">Scala04_NightMareLevelFunction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>( name : <span class="type">String</span> ): <span class="type">String</span> = &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;Name:&quot;</span> + name</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明函数后，可以将函数体最后一行代码作为函数的返回值，所以return关键字可以省略</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>( name : <span class="type">String</span> ): <span class="type">String</span> = &#123;</span><br><span class="line">       <span class="string">&quot;Name:&quot;</span> + name</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果函数可以自动推断出返回值类型，那么返回值类型可以省略</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>( name : <span class="type">String</span> ) = &#123;</span><br><span class="line">       <span class="string">&quot;Name:&quot;</span> + name</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果函数逻辑只有一行代码，那么花括号可以省略</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f4</span></span>() = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果参数列表没有参数，那么参数列表的小括号可以省略</span></span><br><span class="line">   <span class="comment">// val f5 = &quot;bcd&quot;</span></span><br><span class="line">   <span class="comment">// 统一访问原则</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f5</span> </span>= <span class="string">&quot;bcd&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果函数的参数列表已声明，那么调用时可以使用小括号，也可以不使用</span></span><br><span class="line">   <span class="comment">// 如果函数的参数列表未声明，那么调用时不能使用小括号</span></span><br><span class="line">   <span class="comment">//println(f4)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果函数体中有明确的return操作，那么函数必须声明返回值类型</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f6</span></span>( name : <span class="type">String</span> ) = &#123;</span><br><span class="line">       <span class="keyword">val</span> flg = <span class="literal">true</span></span><br><span class="line">       <span class="keyword">if</span> ( flg ) &#123;</span><br><span class="line">           <span class="string">&quot;Name:&quot;</span> + name</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果函数声明返回值类型为Unit,那么函数体中的return操作不起作用</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f7</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果Unit类型也想省略，可以同时将等号省略</span></span><br><span class="line">   <span class="comment">// 将这样的函数称之为过程</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f8</span></span>() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//println(f8)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果只关系逻辑，而不关心方法名称，那么函数名称可以省略，def关键字也可以省略</span></span><br><span class="line">   <span class="comment">//()-&gt;&#123;println(&quot;xxxxxx&quot;)&#125;</span></span><br><span class="line">   <span class="comment">// 匿名函数</span></span><br><span class="line">   <span class="comment">//() =&gt; &#123;println(&quot;yyyyy&quot;)&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// scala语法中，万物皆函数，所以什么都可以是函数</span></span><br><span class="line">   <span class="comment">// 变量也能是函数</span></span><br><span class="line">   <span class="keyword">val</span> f9 = (i:<span class="type">Int</span>) =&gt; &#123;println(<span class="string">&quot;i = &quot;</span> + i)&#125;;</span><br><span class="line"></span><br><span class="line">   f9(<span class="number">10</span>)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">   <span class="keyword">val</span> f10 = () =&gt; println(<span class="string">&quot;yyyyy&quot;</span>)</span><br><span class="line">   f10()</span><br><span class="line">   <span class="keyword">val</span> f11 = (a:<span class="type">Int</span>) =&gt; a + <span class="number">1</span></span><br><span class="line">   println(f11(<span class="number">1</span>))</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>匿名函数参数最多为22个（1~22），可以用集合作为参数实现多个参数。

闭包：当前函数的内部用到了函数之外的变量，为了防止外部变量在函数内失效，将变量包含道函数内部，形成闭合的效果，称之为闭包。即改变了变量的生命周期。科里化中一定会出现闭包。

因为方法调用方法，一个方法执行完毕之后一定会弹栈，所以方法中定义的变量在弹栈时会失效。
</code></pre>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala05_HellLevelFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 地狱版函数式编程</span></span><br><span class="line">        <span class="comment">// TODO 函数的参数是函数</span></span><br><span class="line">        <span class="comment">// 将一个函数作为参数传给另外一个函数</span></span><br><span class="line">        <span class="comment">// 声明的方式 ： 参数名：参数类型</span></span><br><span class="line">        <span class="comment">// f : (Int)=&gt;Unit</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>( param : (<span class="type">Int</span>)=&gt;<span class="type">Unit</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            param(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ff</span></span>(i:<span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(<span class="string">&quot;i = &quot;</span> + i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//f(ff)</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>( param:()=&gt;<span class="type">Unit</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            param()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f11</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(<span class="string">&quot;f111111&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//f1( f11 )</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 将一个函数作为函数的返回值返回,不执行这个函数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f22</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(<span class="string">&quot;f222222&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果将函数作为返回值返回，需要增加返回值类型</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>():()=&gt;<span class="type">Unit</span> = &#123;</span><br><span class="line">            f22</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果想要</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f222</span></span>() = &#123;</span><br><span class="line">            f22 _</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//f2()()</span></span><br><span class="line">        <span class="comment">//f222()()</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>( i : <span class="type">Int</span> ) = &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">f33</span></span>( j : <span class="type">Int</span> ) = &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">f333</span></span>( f:(<span class="type">Int</span>, <span class="type">Int</span>)=&gt;<span class="type">Int</span> ) = &#123;</span><br><span class="line">                    f(i, j)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                f333 _</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f33 _</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">innerFunction</span></span>(x:<span class="type">Int</span>, y:<span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            x * y</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(f3(<span class="number">10</span>)(<span class="number">10</span>)(innerFunction))</span><br><span class="line">        <span class="comment">// 使用匿名函数传递参数</span></span><br><span class="line">        <span class="comment">//println(f3(10)(10)((x:Int, y:Int)=&gt;&#123;x+y&#125;))</span></span><br><span class="line">        <span class="comment">//println(f3(10)(10)((x, y)=&gt;&#123;x+y&#125;))</span></span><br><span class="line">        <span class="comment">//println(f3(10)(10)(_*_))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数柯里化</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f4</span></span>(i:<span class="type">Int</span>)(j:<span class="type">Int</span>)(p:(<span class="type">Int</span>,<span class="type">Int</span>)=&gt;<span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            p(i, j)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数闭包：如果函数中使用外部的变量，为了防止变量数据丢失，将变量包含到函数的内部，形成闭合的效果，称之为闭包，可以改变变量的生命周期</span></span><br><span class="line"></span><br><span class="line">        println(f4(<span class="number">5</span>)(<span class="number">10</span>)(_ - _))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>将方法体内的函数作为返回值返回，而不执行这个函数：
</code></pre>
<p>①增加返回值类型为该函数</p>
<p>②如果不指定返回值类型，则在函数后增加”_”符号，表示不执行函数</p>
<p>val f2: (String, Double) &#x3D;&gt; Int &#x3D; (a: String, b : Double) &#x3D;&gt; a.toInt + b.toInt的含义是：定义一个变量，规定变量的参数列表和返回值；将等号右边的匿名函数赋给该变量。</p>
<p>scala中不能省略返回值类型。因为自己调用自己，推断不出来自己的返回值类型，所以需要添加上返回值类型。</p>
<p>栈滚动异常（stackoverflow）：递归深度过大。</p>
<p>栈内存溢出：多个线程并行时会出现栈内存溢出，没有足够的栈可以分配。</p>
<p>方法区溢出：虚拟机的1&#x2F;64到1&#x2F;4的内存分配给方法区，如果加载的类模版过多（如Tomcat）造成方法区溢出。</p>
<p>堆内存溢出：进行fullGC后还是没有足够的堆内存用于创建对象，则堆内存溢出。</p>
<p>栈上分配：将对象创建在栈上，当方法被弹栈时，该对象也会弹栈，可以有效利用内存。</p>
<p>逃逸分析：如果创建的对象被返回到外部的调用函数，那么该对象不能被弹栈，即逃逸出去。那么虚拟机不会在栈上创建该对象，而是在堆中创建。</p>
<p>System.GC能主动调用jvm的GC机制，但是不一定执行，由GC的内部逻辑决定。回收时会调用对象的finilize方法，可以在方法中决定是否继续回收该对象。</p>
<p>G1垃圾回收算法、CMS垃圾回收算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i++;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>打印结果为2。return会开一个临时变量，将return的值存储在该临时变量中；第一个return将0存储在临时变量中，i变为1；再执行finally中的return语句，将++i=2存储到临时变量中，然后返回。所以结果为2。
</code></pre>
<p>包名  域名的反写+项目名+模块+程序类型，因为在实际开发中对包名要求不严格，可以缩写。</p>
<p>java中包的作用：①对不同类的管理②防止同名包冲突③包访问权限</p>
<p>scala中包的作用：①package关键字可以多次声明②scala源码包和包名没有直接的关系③package可以声明作用域，且子包可以直接访问父包的类，不需要导包④scala将包当成一个对象，即包对象，可以在包对象中创建变量和函数</p>
<p>native修饰符：调用底层的代码实现功能，提高运行效率，解决jvm无法操作硬件的局限。</p>
<p>protected访问权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ProtectedClone &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AAA aaa = new AAA();</span><br><span class="line"></span><br><span class="line">        aaa.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AAA&#123;</span><br><span class="line">//    protected Object clone()&#123;</span><br><span class="line">//        return null;</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>如果不重写AAA中的clone方法，那么在ProtectedClone类中无法对clone方法进行调用。因为clone方法的**提供者**为对象AAA的父类Object，而clone的**调用者**为ProtectedClone类；AAA的父类与ProtectedClone的没有父子关系，所以不能在ProtectedClone类中调用clone方法；若在AAA中重写clone方法，那么动态绑定机制，AAA对象会调用自己的clone方法，而ProtectedClone和AAA同包，所以ProtectedClone可以调用AAA的clone方法。
</code></pre>
<p>el表达式 通过反射调用类属性和方法</p>
<pre><code>java中用import 可以①导入某个类②导入包中所有的类③导入类的静态属性和方法。import static com.atguigu.bigdata.java.ConstBean.*就可以导入ConstBean类中的所有的静态方法，直接写方法即可，不需要写类名。

scala中的breaks中的breakable静态方法，可以导入该静态方法import scala.util.control.Breaks._ ，然后直接用该方法。在scala中用伴生对象访问时可以通过类名直接访问方法，模拟静态语法。



scala赋予import关键字更多功能：①import关键字可以在任意地方使用②可以导入指定包中的类，但是java.lang和scala（predef）中的类不需要导入。③导入指定包中所有的类。在scala中使用_代替java中的*。但是在编译中，只会加载用到的类。④导入指定包中的多个类，可以采用大括号，声明在一行。⑤scala中的import可以导包，如果是包对象，可以访问其属性和方法。⑥scala可以在导类的时候隐藏指定的类 java.util.&#123;HashMap=&gt; _ ,_ _&#125;将HashMap类隐藏。⑦scala可以给导入的类起别名，两种方式为：java.util.&#123;HashMap=&gt;JacaHashMap, _&#125;，type hm = java.util.HashMap⑧scala中包的概念是相对路径，但这样可能会出现冲突。一般采用绝对路径的方式来解决。_      **_ root_**.java.util.HashMap
</code></pre>
<p>scala包中的predef伴生对象，在使用时可以省略，包括println、classOf等。</p>
<p> &#x3D; classOf[User]	classOf[User]  获取当前User的类的信息，获取方法区的内存。 9:15？？？</p>
<p>D:\MyWork\Program\jdk-8u202\jre\下的lib和classes文件夹		引导类加载器，加载核心类库</p>
<p>D:\MyWork\Program\jdk-8u202\jre\libxt\下的jar包和classes文件夹	扩展类加载器，加载扩展类库</p>
<p>classpath	应用类加载器，加载classpath下的类</p>
<pre><code>双亲委派机制：加载类时，会逐级委派上级加载器，加载其路径下的类，如果启动类加载器找到类则直接加载，没有找到类，会返回null；扩展类加载器再加载路径下的类，找到直接加载类，否则返回异常；应用类加载器再查找路径下的类，找到则直接加载，否则返回classnotfoundexception。为什么获取启动类加载器会返回null，为什么启动类加载器返回null而不是异常？因为启动类加载器不是java实现的，无法返回异常，而扩展类加载器是java实现的。



scala中的访问权限和java的有区别①protected权限只能由同类或子类访问，同包不能访问②不加访问权限时，默认为public。③scala中没有包访问权限的概念。**private[包名]** ，即包内私有，指明能访问的包的名称（子包也能访问）。

类的无权限修饰的属性在编译后全都是private的，但同时提供两个公共的方法（set,get），用于访问和修改这个属性。（类似el表达式，通过反射获取对象的方法，通过方法访问对应的属性。）但是框架中有属性对应的方法的名称规范，所以scala提供了**@BeanProperty注释**，来额外生成一对标准名称的getxxx和setxxx方法，以匹配java开发规范。	private修饰的属性，编译后生成private修饰的get、set方法；val修饰的属性，编译后只生成get方法。

由于在伴生对象中定义的属性都会在编译时生成set和get方法，所以在写方法时需要注意不能和自动生成的方法重复，可以改变参数形成重载。
</code></pre>
<p>scala也可以给属性默认初始化，用”_”赋值。</p>
<p> <strong>_  的用法：①包中所有类②系统默认初始化③将函数不执行返回④参数占位符⑤隐藏导入的类⑥标识符⑦绝对路径</strong>⑧case _ 不管什么值都匹配⑨case _:BigInt &#x3D;&gt;…  当后面不用该变量，不关心变量时，可以用 _ 代替。</p>
<p><strong>[] 的用法：①protected[包名]②泛型 classOf[] , inInstanceOf[] asInstanceOf[] ，Array[]③实现特质中方法时指向类  super[Operate].insert( )</strong></p>
<p>scala常用方法：**isInstanceOf[ ]**判断类型，方括号内是泛型，定义函数时没写小括号，此处也不写小括号 	  			**asInstanceOf[ ]**转换类型</p>
<pre><code>        classOf[User]  获取当前User的类的信息，获取方法区的内存。
</code></pre>
<p>构造方法：</p>
<pre><code>1.apply：

Range等对象，可以不使用new关键字构建：会调用伴生对象的特殊方法构建对象。可以在伴生对象中定义apply方法，def apply():Emp  = new Emp() 。如果直接写类名，则会编译为  **类名.apply（）**来调用该构造方法返回类对象。如Range(1,10,2)直接返回该数组对象，因为编译时会调用apply方法返回new Range（1,10,2）对象。好处是①增加了整体性②私有化构造方法，通过调用apply获取对象。可以用于单例模式等。③apply不一定要返回本类的对象，可以是其他类的对象。

用new调用的是构造方法，不用new创建对象则调用apply方法。

2.构造函数：

scala语言万物皆对象，万物皆函数。所以class类也是函数，因为类的后面使用小括号声明的参数列表，其实就是构造函数的参数列表。
</code></pre>
<p>①构造函数可以有参数②辅构造函数的名称有特殊要求def this（）｛｝③scala中构造函数分为两大类：主构造函数&amp;辅构造函数（使用<strong>this</strong>声明构造函数）④辅助构造函数一定要直接或间接的调用主构造函数，因为类的主体是由主构造函数来初始化的（没有默认无参构造器的说法）。⑤辅助构造方法在调用其他构造方法时，必须<strong>保证已经声明过其他构造方法</strong>。</p>
<pre><code>构造方法私有化：class User private()&#123;  &#125;,类构造器的括号前加private，可以在伴生对象中添加apply方法，**伴生对象可以访问伴生类中的私有属性和方法。**在外面调用apply获取伴生类对象。



可以将构造参数作为类的属性，但是需要加上var。如class User（**var/val**  username : String）｛  ｝，将传入的参数username作为User类的属性。



枚举类object Color extends Enumeration 9:33

伴生对象中的语句都会执行，因为构建对象时会调用函数体。object Test extends App 9:36
</code></pre>
<p>类的继承：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter01</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name : <span class="type">String</span></span>)</span>&#123;</span><br><span class="line">  println(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">name : <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>可以在继承的类的后面直接跟参数，进入子类构造器后就会先调用父类构造器。
</code></pre>
<p>抽象类：</p>
<pre><code>abstract class Parent&#123;  &#125; 就是抽象类，抽象类中的抽象方法：只有声明，没有实现 def  test（）：Unit

scala中类名前加abstract关键字为抽象类；scala中只有声明没有实现的方法为抽象方法。继承抽象类需要实现抽象方法才能变成实体类，才能构造对象。重写方法需要添加override关键字，但是重写抽象方法不需要override关键字。

scala中的属性也可以是抽象的。一个类中有抽象属性（声明属性但未初始化），那么这个类为抽象类，抽象属性编译时不会生成属性，而是提供了两个抽象的方法。继承抽象类需要将抽象属性补充完整，其实等同于重写属性的set方法和get方法。	子类**重写父类完整的属性**，但是需要**val修饰**的不可变的完整属性才能重写，也需要**添加override**关键字。
</code></pre>
<p>原理：修改和读取age都是调用底层的方法，因为子类中也存在get和set方法， 所以会调用子类的get和set方法，由于动态绑定机制，最终修改和读取的是子类中的重写的属性。局部变量只有在其作用于内才能修改，但是最终修改的是却是子类的属性，所以为了避免这种歧义，将属性用val修饰，如果有修改属性的操作，在编译检查时直接报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.bigdata.scala.chapter01</span><br><span class="line"></span><br><span class="line">object Scala1 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val stu = new Student(&quot;zhangsan&quot;)</span><br><span class="line">    stu.test()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person(name : String)&#123;</span><br><span class="line">  var age : Int = 20</span><br><span class="line"></span><br><span class="line">  def test():Unit = &#123;</span><br><span class="line">    age = 100</span><br><span class="line">    println(age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student(name : String) extends Person(name)&#123;</span><br><span class="line">  override var age : Int = 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>特质（类似AOP编程，将相同的？？9:39  ？？）：</p>
<pre><code>ocp开发原则：即（Open Closed Principle）开闭原则，扩展功能不能修改原有的代码。

面向接口编程体现在  public static void sum(List list)&#123;   &#125;，可以通过需求传入不同类型的集合。



16:20 AAA.class.getInterfaces().length 利用反射查看是否实现接口



java中的接口难以理解，所以scala没有接口的概念和关键字。scala将多个类具有的相同的特征从对象中剥离出来，形成一个特殊结构，称之为特质。如果一个对象符合某个特征（特质），那么可以将这个特征“混入”到对象中。	如果有父类，extends继承父类，用with来混入特质。特质中可以由抽象的属性和方法。

动态混入：创建对象的同时混入特质。在后面跟with + 特征，那么对象中就带有特质，遵循了OCP开发原则，同时扩展了功能，不会对类有影响。
</code></pre>
<p>多特质的初始化和执行特质中的功能：</p>
<pre><code>特质可以混入其他特质：如果类存在父类，会首先初始化父类；如果类存在特质， 会首先初始化特质，在进行类的初始化；父类初始化后，如果类存在多个特质，会从左到右一次初始化。**特质只会初始化一次**，如果之前已经初始化了，不会再次初始化。

初始化顺序从左到右，执行特质中的功能时，是从右向左执行。当前super关键字不是父特质的概念，而是上一个特质的意思（如果最右边的特质没有super，那么是不是全都不会调用？？是）。如果一定要super指向上一级而不是上一个，需要特殊的方式指定 super[Operate].insert( ) 。
</code></pre>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter01</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> people = <span class="keyword">new</span> <span class="type">People</span></span><br><span class="line">    people.insert()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Operate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span> </span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;插入数据&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DB</span> <span class="keyword">extends</span> <span class="title">Operate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;向数据库&quot;</span>)</span><br><span class="line">    <span class="keyword">super</span>.insert()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Operate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;向文件中&quot;</span>)</span><br><span class="line">    <span class="keyword">super</span>.insert()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">DB</span> <span class="keyword">with</span> <span class="title">File</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">    向文件中</span><br><span class="line">    向数据库</span><br><span class="line">    插入数据</span><br></pre></td></tr></table></figure>



<p>9:45 	this：Exception &#x3D;&gt; 	规定约束条件，那么添加约束的方法中就可以使用约束类的属性和方法。但是继承该特质的类也有要求。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Excep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">with</span> <span class="title">MyTrait</span></span>&#123;	<span class="comment">//因为约束是异常，所以只能异常类才能继承</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyTrait</span></span>&#123;</span><br><span class="line">  <span class="comment">//约束：</span></span><br><span class="line">  <span class="keyword">this</span>:<span class="type">Exception</span>=&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>()&#123;</span><br><span class="line">    println(getMessage())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>和scala中的predef伴生对象类似，window.document.getElementById() ，window.alert()在窗口中时，window可以省略。</p>
<p>AOP编程：将业务中的相同的功能剥离出来，以横向的方式交叉的应用到业务中的编程方式。与特质相似。</p>
<p>隐式转换（类型转换）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">值的类型转换</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Implicit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(d:<span class="type">Double</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">      d.toInt</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i : <span class="type">Int</span> = <span class="number">2.0</span></span><br><span class="line">    println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">伴生对象反编译源码：</span><br><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Implicit$</span></span></span><br><span class="line">&#123;</span><br><span class="line">  public static <span class="keyword">final</span>  <span class="type">MODULE</span>$ = <span class="keyword">new</span> ();</span><br><span class="line"></span><br><span class="line">  public void main(<span class="type">String</span>[] args)</span><br><span class="line">  &#123;</span><br><span class="line">    int i = transform$<span class="number">1</span>(<span class="number">2.0</span>D);				<span class="comment">//二次编译时会调用隐式转换</span></span><br><span class="line">    <span class="type">Predef</span>..<span class="type">MODULE</span>$.println(<span class="type">BoxesRunTime</span>.boxToInteger(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> int transform$<span class="number">1</span>(double d)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (int)d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类对象的隐式转换方法</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Implicit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">mysqlToDB</span></span>(mysql: <span class="type">MySQL</span>): <span class="type">DB</span> = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">DB</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> mysql = <span class="keyword">new</span> <span class="type">MySQL</span></span><br><span class="line">    mysql.insert()</span><br><span class="line">    mysql.delete</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;insert&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;delete&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">隐式类转换</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Implicit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> mysql = <span class="keyword">new</span> <span class="type">MySQL</span></span><br><span class="line">    mysql.insert</span><br><span class="line">    mysql.delete</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MySQL</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>: <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(<span class="string">&quot;insert..&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">DB</span>(<span class="params">mysql:<span class="type">MySQL</span></span>)</span>&#123; <span class="comment">//在需要转换的类前加implicit，同时加上需要转化的对象。那么在指定		对象调用该类方法时会转换为该类对象。隐式类不能是顶级的，只能从作用域和继承的类、特质、伴生对象中查找</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>: <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(<span class="string">&quot;delete..&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">隐式参数</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Implicit</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">var</span> name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(<span class="keyword">implicit</span> name:<span class="type">String</span> = <span class="string">&quot;Tom&quot;</span>): <span class="type">Unit</span> =&#123;	<span class="comment">//事先加上implicit关键字，后续要改默认														参数，只需要在加一个隐式变量即可</span></span><br><span class="line">      println(name + <span class="string">&quot; hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>引用类型强转的类需要有实现或继承关系，所以scala中用隐式转换。如predef中有将string类型转为StringOps类型的隐式转换方法，使其能使用StringOps的类方法。

scala编译器在发现编译错误时，可以再次尝试使用转换规则重新编译，看看是否能编译通过。**implicit** def transform(d:Double) : Int = &#123;d.toInt&#125; 制定了类型转换规则，在**二次编译**后能自动调用该转换方法。

隐式转换可以扩展功能，但是**只能有一个参数**（可以通过实现科里化），不能有两个相同的隐式转换。

隐式变量：在OCP原则下改变函数的默认参数赋值，将隐式属性的值作为默认参数。隐式变量值可以覆盖默认参数（在参数列表中添加关键字implicit），和隐式转化方法一样也不能有两个相同的隐式属性。

隐式转换的属性、方法和类应从当前对象的作用域找，没找到则从父类和特质和伴生对象中找。
</code></pre>
<h2 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h2><pre><code>scala集合分为两大类：可变集合和不可变集合（底层存储数组不可变），默认采用不可变集合。集合有三大类，序列seq、集set和映射map

scala集合的类型根据包来确定：scala.collection.mutable和scala.collection.immutable
</code></pre>
<p>11:39  scala的predef是自动导入的，在predef中将Array类的全限定类名进行重命名为Array，所以直接写Array相当于Array的全限定类名。类似的println方法在predef中定义，所以直接使用println即可。</p>
<h3 id="seq-（Array，ArrayBuffer，List，ListBuffer）"><a href="#seq-（Array，ArrayBuffer，List，ListBuffer）" class="headerlink" title="seq:（Array，ArrayBuffer，List，ListBuffer）"></a>seq:（Array，ArrayBuffer，List，ListBuffer）</h3><p>Array是不可变数组，ArrayBuffer是可变数组：</p>
<pre><code>创建数组时需要添加数组中内容的泛型；如果不加泛型，则类型为Nothing。
</code></pre>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)		<span class="comment">//需要添加泛型，否则内部元素为Nothing类型</span></span><br><span class="line"><span class="comment">//用小括号来访问</span></span><br><span class="line">array(<span class="number">0</span>) = <span class="string">&quot;1&quot;</span></span><br><span class="line">array(<span class="number">1</span>) = <span class="string">&quot;2&quot;</span></span><br><span class="line">array(<span class="number">2</span>) = <span class="string">&quot;3&quot;</span></span><br><span class="line">println(array(<span class="number">1</span>))</span><br><span class="line"><span class="comment">//循环打印</span></span><br><span class="line"><span class="keyword">for</span> （elem &lt;- array)&#123;</span><br><span class="line">    println(elem)</span><br><span class="line">&#125;</span><br><span class="line">++方法：</span><br><span class="line"><span class="keyword">val</span> array1 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">AnyVal</span>](<span class="number">3</span>)</span><br><span class="line">    array1(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">    array1(<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">    array1(<span class="number">2</span>) = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> array2:<span class="type">Array</span>[<span class="type">Any</span>] = array.++(array1)	<span class="comment">//不可变数组++会生成新的数组，而不会对本身造成影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构建数组并初始化</span></span><br><span class="line"><span class="keyword">val</span> ints = <span class="type">Array</span>(<span class="number">1</span>,<span class="string">&quot;2&quot;</span>,<span class="number">3</span>)	<span class="comment">//调用apply方法,能自动推断类型</span></span><br></pre></td></tr></table></figure>

<p>Array（实际是一个String数组）数组的方法：</p>
<p>array.length&#x2F;update（，）&#x2F;++()  由于数组不可变，所以++方法会返回一个新的Array数组对象。</p>
<p>array.mkString(“,”)	将String[]数组装换成字符串，用，分隔。</p>
<p>ArrayBuffer：将数组的包装对象作为参数来构建ArrayBuffer对象。14:17</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">val</span> ints = <span class="type">ArrayBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    ints.append(<span class="number">5</span>)</span><br><span class="line">    ints.remove(<span class="number">1</span>)</span><br><span class="line">    println(ints(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历集合</span></span><br><span class="line"><span class="comment">//    def f(x:Any) = &#123;</span></span><br><span class="line"><span class="comment">//      println(x)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    ints.foreach(f)</span></span><br><span class="line"><span class="comment">//    ints.foreach((x:Any)=&gt;&#123;println(x)&#125;)	//用匿名函数接收并执行打印</span></span><br><span class="line"><span class="comment">//    ints.foreach((x)=&gt;println(x))</span></span><br><span class="line"><span class="comment">//    ints.foreach(println(_))</span></span><br><span class="line">    ints.foreach(println)	<span class="comment">//至简模式</span></span><br></pre></td></tr></table></figure>

<p>ab.append（,,）&#x2F;mkString(“,”)&#x2F;update（，）&#x2F;remove（，）</p>
<p>ab(0)&#x3D;9 和 ab.update(0,9)效果一样。</p>
<p>List：</p>
<pre><code>List(1,2,3) 有序可重复的不可变集合,会产生新的集合
</code></pre>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">不可变<span class="type">List</span>集合</span><br><span class="line">	<span class="keyword">val</span> numList = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">//    val ints: List[Int] = numList:+(5)</span></span><br><span class="line"><span class="comment">//    ints.foreach(println)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    val ints1: List[Int] = 5::(numList)</span></span><br><span class="line"><span class="comment">//    ints1.foreach(println)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    val ints2:List[Int] = 5+:(numList)	//同::</span></span><br><span class="line"><span class="comment">//    ints2.foreach(println)</span></span><br><span class="line"><span class="comment">//    numList(1) = 9                 //List只有updated方法，所以直接用numList不行</span></span><br><span class="line"><span class="comment">//    val list: List[Any] = numList.updated(1,&quot;1&quot;)</span></span><br><span class="line"><span class="comment">//    list.foreach(println)</span></span><br><span class="line"><span class="comment">//    val list1: List[Int] = numList.drop(2)	//丢弃的数量</span></span><br><span class="line"><span class="comment">//    list1.foreach(println)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    val numList3: List[Int] = 1::2::3::Nil  //从右向左将数加入到Nil空集合中</span></span><br><span class="line"><span class="comment">//    numList3.foreach(println)</span></span><br><span class="line">    <span class="keyword">val</span> numList4 = <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> numList5: <span class="type">List</span>[<span class="type">Int</span>] = <span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::numList4:::<span class="type">Nil</span>	<span class="comment">//扁平化</span></span><br><span class="line">    numList5.foreach(println)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>Nil是一个集合的对象，是一个空集合。  var list = 1::2::3::Nil 从右向左构建了List（1,2,3）集合。

val list = 1::2::3::numList:::Nil 三个冒号表示将集合中的元素拆分（称为扁平化）后加入到Nil中。

list.mkString(&quot;-&quot;)/++()/:+(5)/::(6)/+:() 将数字调整到前面/updated(,) List集合无法使用小括号方式/
</code></pre>
<p>drop（）参数为丢弃的数量&#x2F;</p>
<p>ListBuffer(1,2,3,4)  可变集合</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">val</span> ints = <span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">//    ints.update(1,5)</span></span><br><span class="line">    ints(<span class="number">1</span>) = <span class="number">5</span>				<span class="comment">//可以使用，底层调用update</span></span><br><span class="line"><span class="comment">//    ints.append(5,6)</span></span><br><span class="line"><span class="comment">//    ints.insert(1,0,1,2)  // 第一个数表示插入位置，后续时插入的数据</span></span><br><span class="line"><span class="comment">//    ints.remove(2)          //移除下标为2的数据</span></span><br><span class="line"><span class="comment">//    ints.remove(1,2)        //移除下标为1及其之后的2个数据</span></span><br><span class="line"><span class="comment">//    println(ints(1))        //底层调用了apply构造了不可变数组，输出该数组的指定值</span></span><br><span class="line">    ints.foreach(println)</span><br></pre></td></tr></table></figure>

<p>lb.mkString(“,”)&#x2F;update( , ) 或 lb(0)&#x3D;9 &#x2F;append()&#x2F;insert( , )&#x2F;remove()&#x2F;</p>
<h3 id="set"><a href="#set" class="headerlink" title="set:"></a>set:</h3><pre><code>默认为无序不可重复的不可变数组，导入collection.mutable包，mutable.Set为可变数组
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val ints = Set(1,2,3,4,4,4,5,6)   //调用predef中的immutable.Set的apply方法，是不可变数组</span><br><span class="line">    val ints1 = collection.mutable.Set(1,2,3,4,4,4,5) //创建可变Set集合</span><br><span class="line">    ints1.add(4)</span><br><span class="line">    ints1.update(9,true)</span><br><span class="line">    ints1.update(4,false)   //set集合中的upset可以用于删除数据，第一个参数为删除值，第二个为是否删除</span><br><span class="line">    ints1.remove(3)         //删除指定的数据</span><br><span class="line">    val ints2: mutable.Set[Int] = ints1.-(2)  //返回一个新集合，将2删去</span><br><span class="line">    ints1.foreach(println)</span><br></pre></td></tr></table></figure>

<pre><code> ms.add()/update()/remove()    .-() 会产生新的数组/
</code></pre>
<h3 id="map-15：45"><a href="#map-15：45" class="headerlink" title="map:  15：45"></a>map:  15：45</h3><pre><code>scala的键值对：K -&gt; V，也可以将其写为两个元素的元组（K,V）
</code></pre>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> stringToInt: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = <span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>,<span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>,<span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> stringToInt1: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = stringToInt.+(<span class="string">&quot;d&quot;</span>-&gt;<span class="number">4</span>) <span class="comment">//不可变增加键值对返回新Map对象</span></span><br><span class="line">    <span class="comment">/*Option只有两个对象，None和Some，如果有值为Some，没有为None。None调用其他方法会报错，所以应该调用getOrElse。如果是Some则返回值，如果是None则返回指定的默认值*/</span></span><br><span class="line">    <span class="keyword">val</span> maybeInt: <span class="type">Option</span>[<span class="type">Int</span>] = stringToInt.get(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    println(maybeInt.getOrElse(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">//Map对象已经提供了getOrElse方法，可以直接调用</span></span><br><span class="line">    println(stringToInt.getOrElse(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stringToInt2 = mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>,<span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>,<span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span>)    <span class="comment">//可变的Map集合</span></span><br><span class="line">    stringToInt2.update(<span class="string">&quot;a&quot;</span>,<span class="number">11</span>)   <span class="comment">//修改某个key的value值</span></span><br><span class="line">    <span class="keyword">val</span> i: <span class="type">Int</span> = stringToInt2.getOrElse(<span class="string">&quot;a&quot;</span>,<span class="number">0</span>)</span><br><span class="line">    stringToInt2.remove(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">//    println(stringToInt)</span></span><br><span class="line"><span class="comment">//    println(stringToInt.mkString(&quot;,&quot;))</span></span><br><span class="line"><span class="comment">//    stringToInt.foreach(println)</span></span><br><span class="line"><span class="comment">//	  for(item &lt;- stringToInt)&#123;</span></span><br><span class="line"><span class="comment">//		println(item)</span></span><br><span class="line"><span class="comment">//	  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Map集合中的key的集合和value的集合</span></span><br><span class="line">    <span class="keyword">val</span> keys: <span class="type">Iterable</span>[<span class="type">String</span>] = stringToInt.keys</span><br><span class="line">    <span class="keyword">val</span> set: <span class="type">Set</span>[<span class="type">String</span>] = stringToInt.keySet</span><br><span class="line">    <span class="keyword">val</span> iterator: <span class="type">Iterator</span>[<span class="type">String</span>] = stringToInt.keysIterator</span><br><span class="line">    <span class="keyword">val</span> values: <span class="type">Iterable</span>[<span class="type">Int</span>] = stringToInt.values</span><br><span class="line">    <span class="keyword">val</span> iterator1: <span class="type">Iterator</span>[<span class="type">Int</span>] = stringToInt.valuesIterator</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//用元组创建Map集合</span></span><br><span class="line">    <span class="keyword">val</span> stringToInt3 = <span class="type">Map</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="comment">//用参数t接收遍历的元组，然后单独取元组的k和v打印出来</span></span><br><span class="line">    stringToInt3.foreach((t)=&gt;&#123;println(t._1+<span class="string">&quot;=&quot;</span>+t._2)&#125;)</span><br></pre></td></tr></table></figure>

<p>Map集合通过<strong>getOrElse（）</strong>取数据。 .contains(key)判读元素是否存在</p>
<p>Map遍历时，直接写元组 for((k,v), &lt;- map){  ptinltn}  ，实际用到了模式匹配。将元组与（k，v）匹配，然后打印</p>
<h3 id="Tuple："><a href="#Tuple：" class="headerlink" title="Tuple："></a><strong>Tuple：</strong></h3><p><strong>元组（元素的组合）,将无关的数据当成一个整体来使用</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tuple: (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Int</span>) = (<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">22</span>)	<span class="comment">//最多放22个元素</span></span><br><span class="line"><span class="keyword">val</span> iterator: <span class="type">Iterator</span>[<span class="type">Any</span>] = tuple.productIterator</span><br><span class="line"><span class="keyword">for</span> (elem &lt;- iterator) &#123;</span><br><span class="line">  println(elem)                     <span class="comment">//遍历元组</span></span><br><span class="line">&#125;</span><br><span class="line">println(tuple.productElement(<span class="number">1</span>))    <span class="comment">//访问元组中的元素</span></span><br><span class="line">println(tuple._2)                   <span class="comment">//同上</span></span><br><span class="line">println(tuple)                      <span class="comment">//打印整个元组</span></span><br></pre></td></tr></table></figure>

<pre><code>（1，&quot;zhangsan&quot;,22），最多只能放22个，和函数的参数一样，tuple中还可以放tuple。
</code></pre>
<p>如果元组中只有两个元素，称之为对偶或键值对：</p>
<pre><code>val t = (&quot;a&quot;,1)

val stringToInt1 = Map((&quot;a&quot;,1),(&quot;b&quot;,2)) 	将两元素的元组可以作为键值对放入map中
</code></pre>
<p>可以通过 _n  ， productElement  和  productIterator  方式遍历元组。</p>
<p>val (id,age,name) &#x3D; (1,20,”zhangsan”)  ;  println（s“$id,$age,$name)	模式匹配上后赋值，然后输出</p>
<h3 id="集合通用的方法："><a href="#集合通用的方法：" class="headerlink" title="集合通用的方法："></a>集合通用的方法：</h3><p>scala中用&#x3D;&#x3D;可以比较内容，java中只能比较内存地址。</p>
<pre><code>.size/length/head/tail/last/init/sum/max/min/product/map/flatMap/filter/groupBy/zip/reduce/fold/foreach/sliding/scan/take/sortWith/sortBy/diff/union/reverse/intersect
</code></pre>
<p>java中的length是底层数组的长度，size是元素个数。scala中是一样的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nums: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    nums.head   <span class="comment">//取第一个元素</span></span><br><span class="line">    nums.tail   <span class="comment">//取除了第一个元素的数组</span></span><br><span class="line">    nums.last   <span class="comment">//取最后一个元素</span></span><br><span class="line">    nums.init   <span class="comment">//取除了最后一个元素的数组</span></span><br><span class="line">    nums.size</span><br><span class="line">    nums.length <span class="comment">//scala中size和length一样，都是元素个数</span></span><br><span class="line"></span><br><span class="line">    nums.sum</span><br><span class="line">    nums.max</span><br><span class="line">    nums.min</span><br><span class="line">    nums.product  <span class="comment">//乘积</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sortBy和sortWith排序</span></span><br><span class="line">    <span class="keyword">val</span> ints: <span class="type">List</span>[<span class="type">Int</span>] = nums.sortBy((num:<span class="type">Int</span>)=&gt; num) <span class="comment">//通过Int型的num来排序，可简写为num=&gt;num，升序排序</span></span><br><span class="line">	<span class="keyword">val</span> ints11: <span class="type">List</span>[<span class="type">Int</span>] = nums.sortBy((num:<span class="type">String</span>)=&gt; num.toInt)<span class="comment">//将字符串转为int再排序</span></span><br><span class="line">    println(ints)     <span class="comment">//通过指定的规则来排序</span></span><br><span class="line">    <span class="keyword">val</span> ints1: <span class="type">List</span>[<span class="type">Int</span>] = nums.sortWith(_&gt;_) <span class="comment">//降序排列，_&lt;_为升序排列</span></span><br><span class="line">    println(ints1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter过滤器</span></span><br><span class="line">    <span class="keyword">val</span> ints2: <span class="type">List</span>[<span class="type">Int</span>] = nums.filter((num)=&gt; num%<span class="number">2</span> == <span class="number">1</span>)  <span class="comment">//过滤出单数</span></span><br><span class="line">    println(ints2)</span><br><span class="line">    <span class="comment">//过滤出集合中以S开头的单词</span></span><br><span class="line">    <span class="keyword">val</span> wordList: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">&quot;Hadoop&quot;</span>,<span class="string">&quot;Hbase&quot;</span>,<span class="string">&quot;Spark&quot;</span>,<span class="string">&quot;Scala&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> wordList1: <span class="type">List</span>[<span class="type">String</span>] = wordList.filter((s)=&gt;<span class="string">&quot;S&quot;</span>.equals(s.substring(<span class="number">0</span>,<span class="number">1</span>)))</span><br><span class="line">    println(wordList1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map映射方法可以将扁平化数据立体化，yield也有映射功能但是功能不强</span></span><br><span class="line">    <span class="keyword">val</span> ints3: <span class="type">List</span>[<span class="type">Int</span>] = nums.map(_*<span class="number">2</span>)  <span class="comment">//将集合中所有元素*2映射到新数组中，匿名函数写全为(x:Int)=&gt;x*2</span></span><br><span class="line">    println(ints3)</span><br><span class="line">    <span class="keyword">val</span> tuples: <span class="type">List</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = nums.map((_,<span class="number">1</span>))<span class="comment">//将集合中元素映射为元组，匿名函数写全(x:Int)=&gt;(x,1)</span></span><br><span class="line">    println(tuples)</span><br><span class="line">    <span class="comment">//flatMap可以将数据扁平化，在将数组扁平化放入Nil时用到:::也是扁平化</span></span><br><span class="line">    <span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>),<span class="type">List</span>(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">    <span class="keyword">val</span> intsToOnceToList = list.flatMap((l:<span class="type">List</span>[<span class="type">Int</span>])=&gt;l)</span><br><span class="line">    println(intsToOnceToList)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">&quot;Hello World&quot;</span>,<span class="string">&quot;Hello Scala&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> strings: <span class="type">List</span>[<span class="type">String</span>] = words.flatMap(_.split(<span class="string">&quot; &quot;</span>)) <span class="comment">//写全为(s:String)=&gt;s.split(&quot; &quot;)</span></span><br><span class="line">    println(strings)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> intToInt = <span class="type">Map</span>((<span class="string">&quot;1&quot;</span>,<span class="number">3</span>),(<span class="string">&quot;2&quot;</span>,<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">val</span> iterable: immutable.<span class="type">Iterable</span>[<span class="type">Any</span>] = intToInt.flatMap(t=&gt;<span class="type">List</span>(t._1,t._2))</span><br><span class="line">    iterable.foreach(println)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    nums.groupBy()</span></span><br><span class="line"><span class="comment">//    nums.reduce</span></span><br><span class="line"><span class="comment">//    nums.foreach	//集合的循环遍历，没有返回值</span></span><br><span class="line"><span class="comment">//    nums.fold</span></span><br><span class="line"><span class="comment">//    nums.sliding	//把一部分数据作为整体（窗口），对窗口做的操作称为窗口函数，窗口可以滑动。</span></span><br><span class="line"><span class="comment">//    nums.scan		//scan将fold操作的中间过程保存为一个数组</span></span><br><span class="line"><span class="comment">//    nums.take()	//从集合中取前n个数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    nums.diff			//两集合的差集（前后顺序对结果有影响）</span></span><br><span class="line"><span class="comment">//    nums.union		//两集合的并集</span></span><br><span class="line"><span class="comment">//    nums.intersect	//两集合的交集</span></span><br><span class="line"><span class="comment">//    nums.reverse      //反转数组</span></span><br><span class="line"><span class="comment">//    nums.zip			//拉链，将对应的数据作为tuple放入集合中</span></span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">用fold方法将句子中的所有字符按顺序放入到一个集合中：</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FoldExecise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sentence = <span class="string">&quot;AAAAAABBBBCCCDD&quot;</span></span><br><span class="line">    <span class="keyword">val</span> arrayBuffer = <span class="type">ArrayBuffer</span>[<span class="type">Char</span>]()</span><br><span class="line">    <span class="keyword">if</span>(arrayBuffer.isInstanceOf[<span class="type">ArrayBuffer</span>[<span class="type">Char</span>]])&#123;</span><br><span class="line">      println(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果参数是集合，每次读取sentence集合时，都会将集合传入</span></span><br><span class="line">    sentence.foldLeft(arrayBuffer)(putArray)</span><br><span class="line"></span><br><span class="line">    println(arrayBuffer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">putArray</span></span>(arr:<span class="type">ArrayBuffer</span>[<span class="type">Char</span>],c:<span class="type">Char</span>) : <span class="type">ArrayBuffer</span>[<span class="type">Char</span>] = &#123;</span><br><span class="line">      println(arr)</span><br><span class="line">      arr.append(c)</span><br><span class="line">      arr</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">统计一个句子中的每个字母的个数：</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FoldExecise2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sentence = <span class="string">&quot;AAAAAABBBBCCCDD&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">charCount</span></span>(map : <span class="type">Map</span>[<span class="type">Char</span>,<span class="type">Int</span>],c : <span class="type">Char</span>) : <span class="type">Map</span>[<span class="type">Char</span>,<span class="type">Int</span>] = &#123;</span><br><span class="line">      map + (c-&gt;(map.getOrElse(c,<span class="number">0</span>) + <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> charToInt: <span class="type">Map</span>[<span class="type">Char</span>, <span class="type">Int</span>] = sentence.foldLeft(<span class="type">Map</span>[<span class="type">Char</span>, <span class="type">Int</span>]())(charCount)</span><br><span class="line">    charToInt.foreach(t =&gt; println(t.productElement(<span class="number">0</span>) + <span class="string">&quot;=&quot;</span> + t._2))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">统计一个数组中的相同单词的个数：</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> wordList = <span class="type">List</span>(<span class="string">&quot;Hello Spark&quot;</span>,<span class="string">&quot;Hello Scala&quot;</span>,<span class="string">&quot;Hello Flink&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> strings: <span class="type">List</span>[<span class="type">String</span>] = wordList.flatMap(s=&gt;s.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> stringToStrings: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">String</span>]] = strings.groupBy(s=&gt;s)</span><br><span class="line">    println(stringToStrings.map(t=&gt;(t._1,t._2.length)))</span><br><span class="line">    println(stringToStrings.foreach(t =&gt; (t.productElement(<span class="number">0</span>), t.productElement(<span class="number">1</span>))))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">统计一个数组中的相同单词的个数（）：</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount1</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> wordList = <span class="type">List</span>((<span class="string">&quot;Hello Spark&quot;</span>,<span class="number">4</span>),(<span class="string">&quot;Hello Scala&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;Hello Flink&quot;</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">val</span> strings: <span class="type">List</span>[<span class="type">String</span>] = wordList.map(t=&gt;(t._1 + <span class="string">&quot; &quot;</span>)*t._2)</span><br><span class="line">    println(strings.flatMap(_.split(<span class="string">&quot; &quot;</span>)).groupBy(t =&gt; t).map(t =&gt; (t._1, t._2.size)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">将两个<span class="type">Map</span>中的相同key的value相加：</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">Map</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CombineMap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> map = <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>]((<span class="string">&quot;a&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">4</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> map1 = <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>]((<span class="string">&quot;a&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">4</span>),(<span class="string">&quot;d&quot;</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stringToInt: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map.foldLeft(map1) &#123;</span><br><span class="line"><span class="comment">//      (map: Map[String, Int], t: (String, Int)) =&gt; map.+(t._1 -&gt; (map.getOrElse(t._1, 0) + t._2))</span></span><br><span class="line">      (map: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>], t: (<span class="type">String</span>, <span class="type">Int</span>)) =&gt; map(t._1) = map.getOrElse(t._1,<span class="number">0</span>) + t._2</span><br><span class="line">        map</span><br><span class="line">    &#125;</span><br><span class="line">    println(stringToInt)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">如果是可变的<span class="type">Map</span>，结果的返回值，或参数map1都可以读取到结果。</span><br></pre></td></tr></table></figure>

<p>map（key）&#x3D; value 可以快捷的改变key对应的value值！</p>
<p>fold类型要相同，foldLeft类型可以不同。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">匹配值：</span><br><span class="line"><span class="keyword">for</span> (ch &lt;- <span class="string">&quot;+-3!&quot;</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> sign = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> digit = <span class="number">0</span></span><br><span class="line">    ch <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &#x27;+&#x27; =&gt; sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> &#x27;-&#x27; =&gt; sign = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">case</span> _ <span class="keyword">if</span> ch.toString.equals(<span class="string">&quot;3&quot;</span>) =&gt; digit = <span class="number">3</span>	<span class="comment">//守卫，如果满足if条件，则匹配该行</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; sign = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(ch + <span class="string">&quot; &quot;</span> + sign + <span class="string">&quot; &quot;</span> + digit)</span><br><span class="line">&#125;</span><br><span class="line">匹配变量：</span><br><span class="line"><span class="keyword">val</span> ch = &#x27;<span class="type">V</span>&#x27;</span><br><span class="line">ch <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &#x27;+&#x27; =&gt; println(<span class="string">&quot;ok~&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> mychar =&gt; println(<span class="string">&quot;ok~&quot;</span> + mychar)	将值给到变量并输出</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println (<span class="string">&quot;ok~~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">匹配类型：</span><br><span class="line"><span class="keyword">val</span> a = <span class="number">7</span></span><br><span class="line"><span class="keyword">val</span> obj = <span class="keyword">if</span>(a == <span class="number">1</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">3</span>) <span class="type">BigInt</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">4</span>) <span class="type">Map</span>(<span class="string">&quot;aa&quot;</span> -&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">5</span>) <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="string">&quot;aa&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">6</span>) <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">7</span>) <span class="type">Array</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">8</span>) <span class="type">Array</span>(<span class="string">&quot;aa&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = obj <span class="keyword">match</span> &#123;	<span class="comment">//类型匹配不考虑泛型，所以b和c是一样的。Array根据泛型底层是不同的数组</span></span><br><span class="line">    <span class="keyword">case</span> a : <span class="type">Int</span> =&gt; a		<span class="comment">//所以和泛型无关，和数组类型有关。</span></span><br><span class="line">    <span class="keyword">case</span> b : <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] =&gt; <span class="string">&quot;对象是一个字符串-数字的Map集合&quot;</span></span><br><span class="line">    <span class="keyword">case</span> c : <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] =&gt; <span class="string">&quot;对象是一个数字-字符串的Map集合&quot;</span></span><br><span class="line">    <span class="keyword">case</span> d : <span class="type">Array</span>[<span class="type">String</span>] =&gt; <span class="string">&quot;对象是一个字符串数组&quot;</span>	<span class="comment">//Array[String]底层是字符串数组，不是泛型</span></span><br><span class="line">    <span class="keyword">case</span> e : <span class="type">Array</span>[<span class="type">Int</span>] =&gt; <span class="string">&quot;对象是一个数字数组&quot;</span>		<span class="comment">//Array[Int]底层是int数组，不是泛型</span></span><br><span class="line">    <span class="keyword">case</span> _ : <span class="type">BigInt</span> =&gt; <span class="type">Int</span>.<span class="type">MaxValue</span>				<span class="comment">//当不关心变量时，可以用_代替</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;啥也不是&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">匹配数组：</span><br><span class="line"><span class="keyword">for</span> (arr &lt;- <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(x, y) =&gt; x + <span class="string">&quot;=&quot;</span> + y	<span class="comment">//匹配变量</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">&quot;以0开头和数组&quot;</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">&quot;什么集合都不是&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;result = &quot;</span> + result)</span><br><span class="line">&#125; </span><br><span class="line">匹配列表：</span><br><span class="line"><span class="keyword">for</span> (list &lt;- <span class="type">Array</span>(<span class="type">List</span>(<span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = list <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> :: <span class="type">Nil</span> =&gt; <span class="string">&quot;0&quot;</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">case</span> x :: y :: <span class="type">Nil</span> =&gt; x + <span class="string">&quot; &quot;</span> + y </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> :: tail =&gt; <span class="string">&quot;0 ...&quot;</span> 		<span class="comment">//0::tail  以0开头的List列表</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line">匹配元组：</span><br><span class="line"><span class="keyword">for</span> (pair &lt;- <span class="type">Array</span>((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = pair <span class="keyword">match</span> &#123; </span><br><span class="line">        <span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">&quot;0 ...&quot;</span> </span><br><span class="line">        <span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; y </span><br><span class="line">        <span class="keyword">case</span> (a,b) =&gt; (b,a)		<span class="comment">//匹配变量</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">&quot;other&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line">匹配对象：</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">unapply</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> number: <span class="type">Double</span> = <span class="number">36.0</span></span><br><span class="line">    number <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Square</span>(n) =&gt; println(n)	<span class="comment">//对象等于36，求参数；调用unapply方法得到构造参数</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;nothing matched&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(z: <span class="type">Double</span>): <span class="type">Option</span>[<span class="type">Double</span>] = <span class="type">Some</span>(math.sqrt(z))<span class="comment">//返回some匹配成功，none匹配失败</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(z: <span class="type">Double</span>): <span class="type">Double</span> = z * z</span><br><span class="line">&#125;</span><br><span class="line">模式匹配</span><br><span class="line"><span class="number">1.</span><span class="keyword">val</span> (id,age,name) = (<span class="number">1</span>,<span class="number">20</span>,<span class="string">&quot;zhangsan&quot;</span>);println（s“$id,$age,$name)	模式匹配，然后输出</span><br><span class="line"><span class="number">2.</span><span class="keyword">for</span>((k,v), &lt;- map)&#123;  ptinltn &#125;   <span class="type">Map</span>遍历时，直接写元组 </span><br><span class="line"><span class="number">3.</span><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">Array</span>(first, second, _*) = arr </span><br><span class="line">  println(first, second) </span><br><span class="line"><span class="number">4.</span></span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;A&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;B&quot;</span>-&gt;<span class="number">0</span>, <span class="string">&quot;C&quot;</span>-&gt;<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> ( (k, v) &lt;- map ) &#123;</span><br><span class="line">    println(k + <span class="string">&quot; -&gt; &quot;</span> + v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((k, <span class="number">0</span>) &lt;- map) &#123;</span><br><span class="line">    println(k + <span class="string">&quot; --&gt; &quot;</span> + <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map <span class="keyword">if</span> v == <span class="number">0</span>) &#123;</span><br><span class="line">    println(k + <span class="string">&quot; ---&gt; &quot;</span> + v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>通过模式匹配得到某个属性的值，主要是代码可读性高，写明了取出姓名</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">match2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tuples = <span class="type">List</span>((<span class="number">1</span>,<span class="string">&quot;zs&quot;</span>,<span class="number">18</span>),(<span class="number">2</span>,<span class="string">&quot;ls&quot;</span>,<span class="number">28</span>),(<span class="number">3</span>,<span class="string">&quot;ww&quot;</span>,<span class="number">38</span>))</span><br><span class="line">    <span class="keyword">val</span> strings: <span class="type">List</span>[<span class="type">String</span>] = tuples.map &#123;	</span><br><span class="line">      <span class="keyword">case</span> (id, name, age) =&gt; name			<span class="comment">//此处case不能省略，要和参数列表区分开</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(strings)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">样例类</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>val (id,age,name) &#x3D; (1,20,”zhangsan”)  ;  println（s“$id,$age,$name)	模式匹配上后赋值，然后输出</p>
<p>样例类：</p>
<p>样例类用case关键字进行声明，是为模式匹配(对象)而优化的类，构造器中的每一个参数都成为val——除非它被显式地声明为var，自动生成apply、unapply、toString、equals、hashCode和copy方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abstract class Amount</span><br><span class="line">case class Dollar(value: Double) extends Amount </span><br><span class="line">case class Currency(value: Double, unit: String) extends Amount</span><br><span class="line">case object NoAmount extends Amount </span><br><span class="line"></span><br><span class="line">for (amt &lt;- Array(Dollar(1000.0), Currency(1000.0, &quot;RMB&quot;), NoAmount)) &#123;</span><br><span class="line">    val result = amt match &#123;</span><br><span class="line">        case Dollar(v) =&gt; &quot;$&quot; + v</span><br><span class="line">        case Currency(v, u) =&gt; v + &quot; &quot; + u</span><br><span class="line">        case NoAmount =&gt; &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(amt + &quot;: &quot; + result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样例类的copy方法可以将对象复制，Dollar(20.0).copy(value&#x3D;30.0)  赋值并改变初始值</p>
<p>密封类：如果想让case类的所有子类都必须在申明该类的相同的源文件中定义，可以将样例类的通用超类声明为sealed，这个超类称之为密封类。密封就是不能在其他文件中定义子类。</p>
<p>数组与变长数组的转换：</p>
<p>arr1.toBuffer  &#x2F;&#x2F;定长数组转可变数组   arr2.toArray  &#x2F;&#x2F;变长数组转定长数组</p>
<p>scala数组转为java数组：import scala.collection.JavaConversions.bufferAsJavaList</p>
<p>val javaArr &#x3D; new Processbuilder（arr）</p>
<p>val arrList &#x3D; javaArr.command（） </p>
<p>java的List转Scala数组:   import scala.collection.JavaConversions.asScalaBuffer</p>
<p>val scalaArr:mutable.Buffer[String] &#x3D; arrList</p>
<p>queue:	两个方法enqueue和dequeue</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Queue1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">String</span>]</span><br><span class="line">    queue.enqueue(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    println(queue.dequeue())</span><br><span class="line">    println(queue.dequeue())</span><br><span class="line">    println(queue.dequeue())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stream：  只有读取时才会加载，末尾元素遵循lazy惰性加载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object Stream &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    def numsForm(n: BigInt): Stream[BigInt] = &#123;</span><br><span class="line">      n #:: numsForm(n * 2)</span><br><span class="line">    &#125;</span><br><span class="line">    println(numsForm(1))	//Stream(1,?)</span><br><span class="line">    println(numsForm(1).head)	//1</span><br><span class="line">    println(numsForm(1).tail.tail)	//Stream(4,?)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>view：view方法产出一个总是被懒执行的集合。view不会缓存数据，每次都要重新计算，比如遍历View时。如果没有读取，就不会加载计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val viewSquares2 = (1 to 100).view.map(multiple).filter(eq)</span><br><span class="line">println(viewSquares2)</span><br></pre></td></tr></table></figure>



<p>.par	多线程并行执行</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Thread1</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    (<span class="number">1</span> to <span class="number">5</span>).foreach&#123;println&#125;</span><br><span class="line">    println(<span class="string">&quot;------------&quot;</span>)</span><br><span class="line">    (<span class="number">1</span> to <span class="number">5</span>).par.foreach&#123;println&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> strings1: immutable.<span class="type">IndexedSeq</span>[<span class="type">String</span>] = (<span class="number">1</span> to <span class="number">100</span>).map&#123;<span class="keyword">case</span> _ =&gt; (<span class="type">Thread</span>.currentThread().getName)&#125;</span><br><span class="line">    <span class="keyword">val</span> strings2: <span class="type">ParSeq</span>[<span class="type">String</span>] = (<span class="number">1</span> to <span class="number">100</span>).par.map&#123;<span class="keyword">case</span> _ =&gt; <span class="type">Thread</span>.currentThread().getName&#125;</span><br><span class="line">    println(strings1 distinct)</span><br><span class="line">    println(strings2 distinct)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="偏函数："><a href="#偏函数：" class="headerlink" title="偏函数："></a>偏函数：</h2><p>map函数是全量函数，只能对全部数据做转换，所以不能用偏函数。list.collect  支持偏函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartialFunction2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    def addOne(x : Any) : Any =&#123;</span></span><br><span class="line"><span class="comment">//      x match &#123;</span></span><br><span class="line"><span class="comment">//        case x:Int =&gt; x + 1</span></span><br><span class="line"><span class="comment">//        case _ =&gt;</span></span><br><span class="line"><span class="comment">//      &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> unit: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = &#123;   <span class="comment">//过滤需要的数据</span></span><br><span class="line">        <span class="keyword">if</span> (x.isInstanceOf[<span class="type">Int</span>]) <span class="literal">true</span></span><br><span class="line">        <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Any</span>) = &#123;      <span class="comment">//将返回true的数据交给apply处理</span></span><br><span class="line">        x.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map函数是全量函数，所以不支持偏函数。</span></span><br><span class="line"><span class="comment">//    list.map(unit))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以用collect方法</span></span><br><span class="line">    println(list.collect(unit))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scala中对偏函数进行了优化，可以简写，直接使用case就可以：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartialFunction3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ints: <span class="type">List</span>[<span class="type">Int</span>] = list.collect&#123;<span class="keyword">case</span> x:<span class="type">Int</span> =&gt; x+<span class="number">1</span>&#125;	<span class="comment">//通过case实现偏函数的功能</span></span><br><span class="line">    println(ints)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象控制：可以实现对算法的封装"><a href="#抽象控制：可以实现对算法的封装" class="headerlink" title="抽象控制：可以实现对算法的封装"></a>抽象控制：可以实现对算法的封装</h2><p>如果参数是函数，且函数参数没有输入值，也没有返回值，即类似def myRunInThread(f1:  &#x3D;&gt; Unit)  函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ChouXiangKongZhi</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(p: =&gt; <span class="type">Unit</span>) =&#123;</span><br><span class="line">      p</span><br><span class="line">    &#125;</span><br><span class="line">    f &#123;									调用了方法f，并将f中的代码作为参数执行</span><br><span class="line">      <span class="keyword">for</span>(elem &lt;- <span class="number">1</span> to <span class="number">10</span>)&#123;</span><br><span class="line">        println(elem)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="java中："><a href="#java中：" class="headerlink" title="java中："></a>java中：</h4><p>10:25泛型只能对后续的操作做约束。如果没有用到该对象的类型，则不会报错，用到该对象的类型，则报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanXing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Emp</span>());</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = list;</span><br><span class="line">        users.add(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(users);	<span class="comment">//此时users虽然泛型是User，但是users中有Emp对象，打印不报错</span></span><br><span class="line">    &#125;											<span class="comment">//但是循环遍历会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传对象：</p>
<p>public static <T extends User> void test(T t) {  System.out.println(t);  }	允许传入User子类，有上限</p>
<p>public static <T super User> void test(T t) {  System.out.println(t);  }	<strong>报错</strong>，不能传父类对象，不合语法</p>
<p>传类型：</p>
<p>public static <T> void test(Class&lt;? extends User&gt; t) {  System.out.println(t);  }	允许传入User子类，有上限</p>
<p>public static <T> void test(Class&lt;? super User&gt;  t) {  System.out.println(t);  }	允许传入User子类，有上限</p>
<h4 id="scala中协变和逆变："><a href="#scala中协变和逆变：" class="headerlink" title="scala中协变和逆变："></a>scala中协变和逆变：</h4><p>java中不允许子类或父类泛型的对象赋值给带泛型的引用。但是scala有协变和逆变。</p>
<p>val a : AAA[User] &#x3D; new AAA[SubUser] ()</p>
<p>class AAA[+User]  称为协变，可以将AAA的子类泛型的对象赋给AAA的父类泛型的引用</p>
<p>val a : AAA[User] &#x3D; new AAA[ParentUser] ()</p>
<p>class AAA[-User]  称为逆变，可以将AAA的子类泛型的对象赋给AAA的父类泛型的引用</p>
<p>逆变就是泛型变成其父类，父类的功能少，所以称为逆变。协变相反。</p>
<h4 id="scala中的泛型："><a href="#scala中的泛型：" class="headerlink" title="scala中的泛型："></a>scala中的泛型：</h4><p>def test**[ T  &lt;:  User ]**( T:t ) :Unit &#x3D; {}  泛型的上限，可以传入子类</p>
<p>def test**[ T  &gt;:  User ]**( T:t ) :Unit &#x3D; {}  scala中泛型没有下限，可以传入任意类，底层相当于不加泛型。</p>
<p><img src="F:/Typora/图片/线程安全问题.PNG" alt="线程安全问题"></p>
<p>如上图不会出现线程安全问题，因为main方法压栈，对象创建在栈中，不会有公用属性。</p>
<p>如果将ss创建在类中方法外，则在只有一个类对象时，需要考虑线程安全问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">CJ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/scala%E7%BC%96%E7%A8%8B/">http://example.com/2023/05/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/scala%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BC%96%E7%A8%8B2/" title="java编程2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java编程2</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/" title="JavaScript"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CJ</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">419</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">集合：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#seq-%EF%BC%88Array%EF%BC%8CArrayBuffer%EF%BC%8CList%EF%BC%8CListBuffer%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">seq:（Array，ArrayBuffer，List，ListBuffer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">1.2.</span> <span class="toc-text">set:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-15%EF%BC%9A45"><span class="toc-number">1.3.</span> <span class="toc-text">map:  15：45</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tuple%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">Tuple：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">集合通用的方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">偏函数：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%8E%A7%E5%88%B6%EF%BC%9A%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">3.</span> <span class="toc-text">抽象控制：可以实现对算法的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%9A"><span class="toc-number">4.0.1.</span> <span class="toc-text">java中：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scala%E4%B8%AD%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98%EF%BC%9A"><span class="toc-number">4.0.2.</span> <span class="toc-text">scala中协变和逆变：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scala%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.0.3.</span> <span class="toc-text">scala中的泛型：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/MySQL/%E6%B3%A8%E8%A7%A3@Select%E5%92%8C@Insert/" title="注解@Select和@Insert">注解@Select和@Insert</a><time datetime="2023-05-06T05:48:28.906Z" title="发表于 2023-05-06 13:48:28">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B3%A8%E8%A7%A3@EnableAutoConfiguration/" title="注解@EnableAutoConfiguration">注解@EnableAutoConfiguration</a><time datetime="2023-05-06T05:48:06.027Z" title="发表于 2023-05-06 13:48:06">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%A6%BB%E7%BA%BF/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E6%A1%86%E6%9E%B6/" title="大数据集群监控框架">大数据集群监控框架</a><time datetime="2023-05-06T05:42:56.298Z" title="发表于 2023-05-06 13:42:56">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E9%AB%98%E5%B9%B6%E5%8F%91/HashMap%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%8AConcurrentHashMap%E5%8E%9F%E7%90%86/" title="HashMap并发问题及ConcurrentHashMap原理">HashMap并发问题及ConcurrentHashMap原理</a><time datetime="2023-05-06T05:31:21.103Z" title="发表于 2023-05-06 13:31:21">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E9%AB%98%E5%B9%B6%E5%8F%91/Stream%E5%8E%9F%E7%90%86/" title="Stream原理">Stream原理</a><time datetime="2023-05-06T05:31:21.103Z" title="发表于 2023-05-06 13:31:21">2023-05-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By CJ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>