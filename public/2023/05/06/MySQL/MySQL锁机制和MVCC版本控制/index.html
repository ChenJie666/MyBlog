<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL锁机制和MVCC版本控制 | Hexo</title><meta name="author" content="CJ"><meta name="copyright" content="CJ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="#一、MySQL锁机制 1.1 锁分类按锁的粒度 划分：  表锁：表锁是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。 页锁：页锁的粒度是介于行锁和表锁之间的一种锁，页锁是在BDB中支持的一种锁机制，很少提及和使用。 行锁：行锁是粒度最小的锁机制，行锁的加锁开销性能大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。 间隙锁：间隙锁">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL锁机制和MVCC版本控制">
<meta property="og:url" content="http://example.com/2023/05/06/MySQL/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CMVCC%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#一、MySQL锁机制 1.1 锁分类按锁的粒度 划分：  表锁：表锁是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。 页锁：页锁的粒度是介于行锁和表锁之间的一种锁，页锁是在BDB中支持的一种锁机制，很少提及和使用。 行锁：行锁是粒度最小的锁机制，行锁的加锁开销性能大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。 间隙锁：间隙锁">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-06T05:31:21.023Z">
<meta property="article:modified_time" content="2023-05-06T05:31:21.023Z">
<meta property="article:author" content="CJ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/06/MySQL/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CMVCC%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL锁机制和MVCC版本控制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-06 13:31:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">419</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL锁机制和MVCC版本控制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-06T05:31:21.023Z" title="发表于 2023-05-06 13:31:21">2023-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-06T05:31:21.023Z" title="更新于 2023-05-06 13:31:21">2023-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL锁机制和MVCC版本控制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>#一、MySQL锁机制</p>
<h2 id="1-1-锁分类"><a href="#1-1-锁分类" class="headerlink" title="1.1 锁分类"></a>1.1 锁分类</h2><p>按<strong>锁的粒度</strong> 划分：</p>
<ul>
<li><strong>表锁：</strong>表锁是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。</li>
<li><strong>页锁：</strong>页锁的粒度是介于行锁和表锁之间的一种锁，页锁是在BDB中支持的一种锁机制，很少提及和使用。</li>
<li><strong>行锁：</strong>行锁是粒度最小的锁机制，行锁的加锁开销性能大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。</li>
<li><strong>间隙锁：</strong>间隙锁主要用于范围查询的时候，锁住查询的范围，并且间隙锁也是解决幻读的方案。</li>
</ul>
<p>按<strong>使用的方式</strong> 划分：</p>
<ul>
<li><strong>共享锁(S)：</strong>当一个事务对Mysql中的一条数据行加上了S锁，当前事务不能修改该行数据只能执行读操作，其他事务只能对该行数据加S锁不能加X锁。</li>
<li><strong>排它锁(X)：</strong>若是一个事务对一行数据加了X锁，该事务能够对该行数据执行读和写操作，其它事务不能对该行数据加任何的锁，既不能读也不能写。</li>
</ul>
<p>按<strong>思想</strong> 划分：</p>
<ul>
<li><strong>乐观锁：</strong>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。乐观锁需要程序员自己去实现的锁机制」，最常见的乐观锁实现就锁机制是「使用版本号实现」；</li>
<li><strong>悲观锁：</strong>一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观锁的实现是基于Mysql自身的锁机制实现。</li>
</ul>
<h2 id="1-2-MySQL引擎的锁机制"><a href="#1-2-MySQL引擎的锁机制" class="headerlink" title="1.2 MySQL引擎的锁机制"></a>1.2 MySQL引擎的锁机制</h2><p>MySQL引擎介绍以下两种，MyISAM和InnoDB。</p>
<h3 id="1-2-1-MyISAM引擎"><a href="#1-2-1-MyISAM引擎" class="headerlink" title="1.2.1 MyISAM引擎"></a>1.2.1 MyISAM引擎</h3><h4 id="1-2-1-1-概念"><a href="#1-2-1-1-概念" class="headerlink" title="1.2.1.1 概念"></a>1.2.1.1 概念</h4><p>MySQL的<strong>MyISAM储存引擎</strong>就支持表锁，MyISAM的表锁模式有两种：</p>
<ul>
<li>表共享读锁(S)：当一个事务对一张MyISAM表加上了共享读锁(S锁)，当前事务不能修改该表的数据，只能执行读操作，其他事务只能对该表加S锁不能加X锁。</li>
<li>表独占写锁：当一个事务对一张MyISAM表加上了排他写锁(X锁)，只能自己进行读写，其他事务不能对该表添加任何锁，既不能读也不能写。</li>
</ul>
<p><strong>行锁是InnoDB默认的支持的锁机制，MyISAM不支持行锁，这个也是InnoDB和MyISAM的区别之一。</strong></p>
<p>####1.2.1.2 测试表级锁<br>Mysql中可以通过以下sql来显示的在事务中显式的进行加锁和解锁操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显式的添加表级读锁</span></span><br><span class="line">LOCK <span class="keyword">TABLE</span> 表名 READ</span><br><span class="line"><span class="comment">-- 显示的添加表级写锁</span></span><br><span class="line">LOCK <span class="keyword">TABLE</span> 表名 WRITE</span><br><span class="line"><span class="comment">-- 显式的解锁（当一个事务commit的时候也会自动解锁）</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><p>创建一个测试表student，这里要指定存储引擎为MyISAM，并插入两条测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> student( \</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment, \</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">40</span>), \</span><br><span class="line">    score <span class="type">INT</span> \</span><br><span class="line">)ENGINE MyISAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(name, score) <span class="keyword">VALUES</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">60</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(name, score) <span class="keyword">VALUES</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure>
<p>查看一下，表结果如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | score |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | zs   |    60 |</span><br><span class="line">|  2 | ls   |    80 |</span><br><span class="line">+----+------+-------+</span><br></pre></td></tr></table></figure>
<h4 id="MyISAM表级写锁"><a href="#MyISAM表级写锁" class="headerlink" title="MyISAM表级写锁"></a>MyISAM表级写锁</h4><p><strong>1. 第一个窗口执行下面的sql，在session1中给表添加写锁：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK <span class="keyword">TABLE</span> student WRITE;</span><br></pre></td></tr></table></figure>
<p><strong>2.  与此同时再开启一个session2窗口，然后在可以在session2中进行查询或者插入、更新该表数据，可以发现都会处于等待状态，也就是session1锁住了整个表，导致session2只能等待：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p><strong>3. 在session1中进行查询、插入、更新数据，都可以执行成功：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | score |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | zs   |    60 |</span><br><span class="line">|  2 | ls   |    80 |</span><br><span class="line">+----+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update student set score=100 where id = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>
<p><strong>4. 解锁student表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>session2中的查询语句返回结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | score |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | zs   |   100 |</span><br><span class="line">|  2 | ls   |    80 |</span><br><span class="line">+----+------+-------+</span><br><span class="line">2 rows in set (3 min 27.09 sec)</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>从上面的测试结果显示，当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作。</p>
<h4 id="MyISAM表级读锁"><a href="#MyISAM表级读锁" class="headerlink" title="MyISAM表级读锁"></a>MyISAM表级读锁</h4><p><strong>1. 第一步还是在session1给表加读锁。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOCK TABLE student READ;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p><strong>2. 然后在session1中尝试进行插入、更新数据，发现都会报错，只能查询数据。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into student value(4,&quot;ww&quot;,99);</span><br><span class="line">ERROR 1099 (HY000): Table &#x27;student&#x27; was locked with a READ lock and can&#x27;t be updated</span><br></pre></td></tr></table></figure>
<p><strong>3. 最后在session2中尝试进行插入、更新数据，程序都会进入等待状态，只能查询数据，直到session1解锁表session2才能插入、更新数据。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | score |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | zs   |   100 |</span><br><span class="line">|  2 | ls   |    80 |</span><br><span class="line">+----+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into student value(4,&quot;ww&quot;,99);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>从上面的测试结果显示，当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁。</p>
<h4 id="1-2-1-3-MyISAM表级锁竞争情况"><a href="#1-2-1-3-MyISAM表级锁竞争情况" class="headerlink" title="1.2.1.3 MyISAM表级锁竞争情况"></a>1.2.1.3 MyISAM表级锁竞争情况</h4><p>MyISAM存储引擎中，可以通过查询变量来查看并发场景锁的争夺情况<code>show status like &#39;table%&#39;</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;table%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name              <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Table_locks_immediate      <span class="operator">|</span> <span class="number">81</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_locks_waited         <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_open_cache_hits      <span class="operator">|</span> <span class="number">9</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_open_cache_misses    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_open_cache_overflows <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>主要是查看table_locks_waited和table_locks_immediate的值的大小分析锁的竞争情况。</p>
<ul>
<li><strong>Table_locks_immediate：</strong>表示能够立即获得表级锁的锁请求次数；</li>
<li><strong>Table_locks_waited：</strong>表示不能立即获取表级锁而需要等待的锁请求次数分析，<strong>值越大竞争就越严重</strong>。</li>
</ul>
<h4 id="1-2-1-4-并发插入"><a href="#1-2-1-4-并发插入" class="headerlink" title="1.2.1.4 并发插入"></a>1.2.1.4 并发插入</h4><p>在我们平时执行select语句的时候就会隐式的加读锁，执行增、删、改的操作时就会隐式的执行加写锁。</p>
<p>MyISAM存储引擎中，虽然读写操作是串行化的，但是它也支持并发插入，这个需要设置内部变量concurrent_insert的值。</p>
<p>它的值有三个值0、1、2。可以通过以下的sql查看concurrent_insert的默认值为「AUTO(或者1)」。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%concurrent_insert&#x27;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| concurrent_insert | AUTO  |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>NEVER (0)表示不支持并发插入；</li>
<li>AUTO(1）表示在MyISAM表中没有被删除的行，运行另一个线程从表尾插入数据；</li>
<li>ALWAYS (2)表示不管是否有删除的行，都允许在表尾插入数据。</li>
</ul>
<h3 id="1-2-1-5-锁调度"><a href="#1-2-1-5-锁调度" class="headerlink" title="1.2.1.5 锁调度"></a>1.2.1.5 锁调度</h3><p>MyISAM存储引擎中，假如同时一个读请求，一个写请求过来的话，它会优先处理写请求，因为MyISAM存储引擎中认为写请求比读请求重要。</p>
<p>这样就会导致，假如大量的读写请求过来，就会导致读请求长时间的等待，或者”线程饿死”，因此MyISAM不适合运用于大量读写操作的场景，这样会导致长时间读取不到用户数据，用户体验感极差。</p>
<p>当然可以通过设置low-priority-updates参数，设置请求链接的优先级，使得Mysql优先处理读请求。</p>
<br>
### 1.2.2 InnoDB引擎
#### 1.2.2.1 概念
InnoDB和MyISAM不同的是，InnoDB支持**表锁**、**间隙锁**、**Next-key Lock锁**和**行锁**，默认支持的是行锁。

<p><strong>需要注意的是：</strong>InnoDB中的行级锁是对<strong>索引</strong>加的锁，在不通过索引查询数据的时候，InnoDB就会使用表锁。若是Mysql觉得执行索引查询还不如全表扫描速度快，那么Mysql就会使用全表扫描来查询，这是即使sql语句中使用了索引，最后还是执行为全表扫描，加的是表锁。</p>
<h4 id="1-2-2-2-测试行级锁"><a href="#1-2-2-2-测试行级锁" class="headerlink" title="1.2.2.2 测试行级锁"></a>1.2.2.2 测试行级锁</h4><p>若想显式的给表加行级读锁和写锁，可以执行下面的sql语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给查询sql显示添加读锁</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="comment">-- 给查询sql显示添加写锁</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>；</span><br></pre></td></tr></table></figure>
<h4 id="建表-1"><a href="#建表-1" class="headerlink" title="建表"></a>建表</h4><p>创建一个测试表，并插入两条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先把原来的MyISAM表给删除了</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> student;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> student( \</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment, \</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">40</span>), \</span><br><span class="line">    score <span class="type">INT</span> \</span><br><span class="line">)ENGINE INNODB;</span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(name, score) <span class="keyword">VALUES</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">60</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(name, score) <span class="keyword">VALUES</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure>
<h4 id="InnoDB表级写锁（对非索引列加行级写锁）"><a href="#InnoDB表级写锁（对非索引列加行级写锁）" class="headerlink" title="InnoDB表级写锁（对非索引列加行级写锁）"></a>InnoDB表级写锁（对非索引列加行级写锁）</h4><ol>
<li>创建的表中可以看出对表中的字段只有id添加了主键索引，接着就是在session1窗口执行begin开启事务，并执行下面的sql语句：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- 使用非索引字段查询，并显式的添加写锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;zs&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zs   <span class="operator">|</span>    <span class="number">60</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>然后在session2中执行update语句和insert语句，上面更新上锁的是id&#x3D;1的数据行，现在update的是id&#x3D;1的数据，insert的是新的一行数据，会发现程序也都会进入等待状态并超时：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> score <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span>(<span class="number">3</span>,&quot;ww&quot;,<span class="number">99</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>总结：</strong>可见若是使用<strong>非索引查询</strong>，直接就是使用的<strong>表级锁</strong>，锁住了整个表。</li>
</ol>
<h4 id="InnoDB行级写锁（对索引列加行级写锁）"><a href="#InnoDB行级写锁（对索引列加行级写锁）" class="headerlink" title="InnoDB行级写锁（对索引列加行级写锁）"></a>InnoDB行级写锁（对索引列加行级写锁）</h4><ol>
<li>若是session1使用的是id来查询<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">mysql&gt; select * from student where id = 1 for update;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | score |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | zs   |    60 |</span><br><span class="line">+----+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>然后在session2中执行update语句和insert语句，上面更新上锁的是id&#x3D;1的数据行，现在update的是id&#x3D;1的数据，insert的是新的一行数据，会发现update等待并超时，insert成功：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into student value(3,&quot;ww&quot;,99);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; update student set score = 100 where id = 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>总结：</strong>若是使用<strong>索引查询</strong>，就是使用的<strong>行级锁</strong>，锁住了指定的行。但是是否执行索引还得看Mysql的执行计划，对于一些小表的操作，可能就直接使用全表扫描。</li>
</ol>
<p>1.执行非索引条件查询执行的是表锁。<br>2.执行索引查询是否是加行锁，还得看Mysql的执行计划，可以通过explain关键字来查看。<br>3.用普通键索引的查询，遇到索引值相同的，也会对其他的操作数据行的产生影响。</p>
<h4 id="InnoDB普通索引锁住相同行"><a href="#InnoDB普通索引锁住相同行" class="headerlink" title="InnoDB普通索引锁住相同行"></a>InnoDB普通索引锁住相同行</h4><ol>
<li>添加普通索引<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table student add index idx_name(name);</span><br><span class="line">Query OK, 0 rows affected (6.94 sec)</span><br></pre></td></tr></table></figure></li>
<li>修改name为相同值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update student set name = &quot;zs&quot; where id = 2;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student;</span><br><span class="line">+----+------+-------+</span><br><span class="line">| id | name | score |</span><br><span class="line">+----+------+-------+</span><br><span class="line">|  1 | zs   |    60 |</span><br><span class="line">|  2 | zs   |    80 |</span><br><span class="line">|  3 | ww   |    99 |</span><br><span class="line">+----+------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>然后在session1中锁住name&#x3D;”zs”的行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from student where name = &quot;zs&quot; for update;</span><br></pre></td></tr></table></figure></li>
<li>在session2中修改id&#x3D;1的记录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update student set score = 0 where id = 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>总结：</strong>用普通键索引的查询，遇到索引值相同的，也会对其他的操作数据行的产生影响。</li>
</ol>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul>
<li>1.执行非索引条件查询执行的是表锁。</li>
<li>2.执行索引查询是否是加行锁，还得看Mysql的执行计划，可以通过explain关键字来查看。</li>
<li>3.用普通键索引的查询，遇到索引值相同的，也会对其他的操作数据行的产生影响。</li>
</ul>
<h4 id="1-2-2-3-InnoDB间隙锁和Next-Key锁"><a href="#1-2-2-3-InnoDB间隙锁和Next-Key锁" class="headerlink" title="1.2.2.3 InnoDB间隙锁和Next-Key锁"></a>1.2.2.3 InnoDB间隙锁和Next-Key锁</h4><p>当我们使用范围条件查询而不是等值条件查询的时候，InnoDB就会给符合条件的范围索引加锁，在条件范围内并不存的记录就叫做”间隙（GAP）”</p>
<p>InnoDB中引入了间隙锁，解决了事务等级-不可重复读下会产生的幻读问题，只能通过提高隔离级别到串行化来解决幻读现象。</p>
<p><strong>这里抛出几种情况来测试间隙锁：</strong></p>
<ul>
<li>非唯一索引是否会加上间隙锁呢？</li>
<li>主键索引（唯一索引）是否会加上间隙锁呢？</li>
<li>范围查询是否会加上间隙锁？</li>
<li>使用不存在的检索条件是否会加上间隙锁？</li>
</ul>
<p><strong>例如我们执行下面的sql语句，就会对id大于100的记录加锁，在id&gt;100的记录中肯定是有不存在的间隙：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>Next-Key锁是行锁加上记录前的间隙锁的结合。如果一个会话在索引中的记录R上有一个共享或独占的锁，则另一个会话不能按照索引顺序在R之前的间隙中插入新的索引记录。</p>
<h4 id="建表-2"><a href="#建表-2" class="headerlink" title="建表"></a>建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> num <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">3</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;tq&#x27;</span>,<span class="number">100</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> score <span class="operator">|</span> num <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zs   <span class="operator">|</span>    <span class="number">60</span> <span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> zs   <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> ww   <span class="operator">|</span>    <span class="number">99</span> <span class="operator">|</span>   <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> tq   <span class="operator">|</span>   <span class="number">100</span> <span class="operator">|</span>   <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+-----+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h4 id="为非唯一索引单行加锁"><a href="#为非唯一索引单行加锁" class="headerlink" title="为非唯一索引单行加锁"></a>为非唯一索引单行加锁</h4><p>1.接着在session1的窗口开启事务，并执行下面操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where num=3 for update;</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">| id | name | score | num |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">|  3 | ww   |    99 |   3 |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>同时打开窗口session2，并执行新增语句：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;ceshi&#x27;</span>,<span class="number">5000</span>,<span class="number">2</span>);  <span class="comment">-- 程序出现等待</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;ceshi&#x27;</span>,<span class="number">5000</span>,<span class="number">4</span>);  <span class="comment">-- 程序出现等待</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;ceshi&#x27;</span>,<span class="number">5000</span>,<span class="number">1</span>);  <span class="comment">-- 程序出现等待</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;ceshi&#x27;</span>,<span class="number">5000</span>,<span class="number">5</span>);  <span class="comment">-- 程序出现等待</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;ceshi&#x27;</span>,<span class="number">5000</span>,<span class="number">6</span>);  <span class="comment">-- 新增成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;ceshi&#x27;</span>,<span class="number">5000</span>,<span class="number">0</span>);  <span class="comment">-- 新增成功</span></span><br></pre></td></tr></table></figure>
<strong>总结：</strong>从上面的测试结果显示在区间 [1,3] U [3,5] 之间加了锁，是不能够新增数据行，这就是新增num&#x3D;1&#x2F;2&#x2F;4&#x2F;5失败的原因，但是在这个区间以外的数据行是没有加锁的，可以新增数据行。</li>
</ol>
<p>根据索引的有序性，而普通索引是可以出现重复值，那么当我们第一个sesson查询的时候只出现一条数据num&#x3D;3，为了解决第二次查询的时候出现幻读，也就是出现两条或者更多num&#x3D;3这样查询条件的数据。</p>
<h4 id="为唯一索引单行加锁"><a href="#为唯一索引单行加锁" class="headerlink" title="为唯一索引单行加锁"></a>为唯一索引单行加锁</h4><p>因为主键索引具有唯一性，不允许出现重复，那么当进行等值查询的时候id&#x3D;3，只能有且只有一条数据，是不可能再出现id&#x3D;3的第二条数据。</p>
<p>因此它只要锁定这条数据（锁定索引），在下次查询当前读的时候不会被删除、或者更新id&#x3D;3的数据行，也就保证了数据的一致性，所以主键索引由于他的唯一性的原因，是不需要加间隙锁的。</p>
<h4 id="为非唯一索引范围加锁"><a href="#为非唯一索引范围加锁" class="headerlink" title="为非唯一索引范围加锁"></a>为非唯一索引范围加锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">| id | name | score | num |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">|  1 | zs   |    60 |   1 |</span><br><span class="line">|  2 | zs   |    80 |   1 |</span><br><span class="line">|  3 | ww   |    99 |   3 |</span><br><span class="line">|  4 | tq   |   100 |   5 |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>在session1中执行下面的sql语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> num<span class="operator">&gt;=</span><span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>在session2中新增数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into student values(6,&#x27;ceshi&#x27;,5000,2);  -- 程序出现等待</span><br><span class="line">insert into student values(7,&#x27;ceshi&#x27;,5000,4);  -- 程序出现等待</span><br><span class="line">insert into student values(8,&#x27;ceshi&#x27;,5000,1);  -- 新增数据成功</span><br></pre></td></tr></table></figure>
<p><strong>原理：</strong>单查询num&gt;&#x3D;3的时候，在现有的student表中满足条件的数据行,那么在设计者的角度出发，我为了解决幻读的现象：在num&gt;&#x3D;3的条件下是必须加上间隙锁的。<br>而在小于num&#x3D;3中，下一条数据行就是num&#x3D;1了，为了防止在（1，3]的范围中加入了num&#x3D;3的数据行，所以也给这个间隙加上了锁，这就是添加num&#x3D;2数据行出现等待的原因。</p>
<h4 id="使用不存在的检索条件是否会加上间隙锁？"><a href="#使用不存在的检索条件是否会加上间隙锁？" class="headerlink" title="使用不存在的检索条件是否会加上间隙锁？"></a>使用不存在的检索条件是否会加上间隙锁？</h4><p>假如是查询num&gt;&#x3D;8的数据行呢？因为student表并不存在中num&#x3D;8的数据行，num最大num&#x3D;6，所以为了解决幻读（6，8]与num&gt;&#x3D;8也会加上锁。</p>
<br>
#### 1.2.2.4 表锁
意向锁：当一个事务带着表锁去访问一个被加了行锁的资源，那么这个行锁就会升级为意向锁将表锁住。
自增锁：事务插入自增类型的列时，获取自增锁。如果一个事务正在往表中插入自增记录，其他事务都必须等待。

<br>
#### 1.2.2.5 死锁
死锁在InnoDB中才会出现死锁，MyISAM是不会出现死锁，因为MyISAM支持的是表锁，一次性获取了所有的锁，其它的线程只能排队等候。

<p>而InnoDB默认支持行锁，获取锁是分步的，并不是一次性获取所有的锁，因此在锁竞争的时候就会出现死锁的情况。</p>
<p>虽然InnoDB会出现死锁，但是并不影响InnoDB成为最受欢迎的存储引擎，MyISAM可以理解为串行化操作，读写有序，因此支持的并发性能低下。</p>
<p>####死锁案例<br>举一个例子，现在数据库表employee中六条数据，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+------+-------+-----+</span><br><span class="line">| id | name | score | num |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">|  1 | zs   |    60 |   1 |</span><br><span class="line">|  2 | zs   |    80 |   1 |</span><br><span class="line">|  3 | ww   |    99 |   3 |</span><br><span class="line">|  4 | tq   |   100 |   5 |</span><br><span class="line">+----+------+-------+-----+</span><br></pre></td></tr></table></figure>

<p>其中name&#x3D;ldc的有两条数据，并且name字段为普通索引，分别是id&#x3D;2和id&#x3D;3的数据行，现在假设有两个事务分别执行下面的两条sql语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1执行</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"><span class="comment">-- session2执行</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>其中session1事务执行的sql获取的数据行是两条数据，假设先为id&#x3D;1的数据行加排它读锁；然后cpu的时间分配给了session2事务，执行查询为id&#x3D;2的数据行加排它读锁。<br>此时cpu又将时间分配给了session1事务，为id&#x3D;2数据添加排他读锁时发现已经被添加了排它读锁，它就处于等待的状态。<br>当cpu把时间有分配给了session2事务，为id&#x3D;1数据添加排他读锁时发现已经被添加了排它读锁，这样就行了死锁，两个事务彼此之间相互等待。</p>
<h4 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h4><p>首先要解决死锁问题，在程序的设计上，当发现程序有高并发的访问某一个表时，尽量对该表的执行操作串行化，或者锁升级，一次性获取所有的锁资源。</p>
<p>然后也可以设置参数innodb_lock_wait_timeout，超时时间，并且将参数innodb_deadlock_detect 打开，当发现死锁的时候，自动回滚其中的某一个事务。</p>
<br>
## 1.3 事务类型
在默认 的自动事务提交 设置下 select 同Update,Insert,Delete一样都会启动一个事务，这种就是隐式事务。

<p><strong>问题：如更新库存语句如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update stock set leave_stock=leave_stock-sale_stock  where id = 1 and leave_stock &gt;= sale_stock;</span><br></pre></td></tr></table></figure>
<p>那么是否存在一下问题：<br>如果隔离级别是可重复读，执行update库存操作时开启隐式事务，AB事务同时开启，A事务修改库存从6改到5,，但是B事务不可见还是在6基础上减库存，导致少卖的情况发送。</p>
<h3 id="1-3-1-显示事务"><a href="#1-3-1-显示事务" class="headerlink" title="1.3.1 显示事务"></a>1.3.1 显示事务</h3><p>显示事务是一种由你自己指定的事务.这种事务允许你自己决定哪批工作必须成功完成,<br>否则所有部分都不完成.为了给自己的事务定界,可以使用关键字BEGIN TRANSACTION和<br>ROLLBACK TRANSACTION或COMMIT TRANSACTION.<br>BEGIN TRANSACTION—这个关键词用来通知SQL Server一个事务就要开始了.<br>BEGIN TRANSACTION后面发生的每一条S Q L语句都是同一个事务中的一部分.<br>ROLLBACK TRANSACTION—这个关键词用来通知SQL Server自BEGIN TRANSACTION<br>后的所有工作都应取消,对数据库中任何数据的改变都被还原,任何已经创建或删除的对<br>象被清除或恢复.<br>COMMIT TRANSACTION—这个关键词用来通知SQL Server自BEGIN TRANSACTION<br>后的全部工作都要完成并成为数据库的一个永久性部分.在同一个事务中,你不能同时<br>使用ROLLBACK TRANSACTION和COMMIT TRANSACTION.<br>你必须意识到,即使你的脚本中有错误,而你又让SQL Server提交事务,该事务也将执<br>行.如果你打算依赖于现实事务保证数据完整性,必须在脚本中建立错误检查机制.</p>
<h3 id="1-3-2-隐式事务"><a href="#1-3-2-隐式事务" class="headerlink" title="1.3.2 隐式事务"></a>1.3.2 隐式事务</h3><p>隐式事务是SQL Server为你而做的事务.隐式事务又称自动提交事务.如果运行一条<br>I N S E RT语句,SQL Server将把它包装到事务中,如果此I N S E RT语句失败,SQL Server将回滚<br>或取消这个事务.每条S Q L语句均被视为一个自身的事务.</p>
<br> 
## 1.4 总结 
- MyISAM的表锁分为两种模式：「共享读锁」和「排它写锁」。获取的读锁的线程对该数据行只能读，不能修改，其它线程也只能对该数据行加读锁。
获取到写锁的线程对该数据行既能读也能写，对其他线程对该数据行的读写具有排它性。
MyISAM中默认写优先于去操作，因此MyISAM一般不适合运用于大量读写操作的程序中。

<ul>
<li>InnoDB的行锁虽然会出现死锁的可能，但是InnoDB的支持的并发性能比MyISAM好，行锁的粒度最小，一定的方法和措施可以解决死锁的发生，极大的发挥InnoDB的性能。<br>InnoDB中引入了间隙锁的概念来决解出现幻读的问题，也引入事务的特性，通过事务的四种隔离级别，来降低锁冲突，提高并发性能。</li>
</ul>
<p><strong>需要注意的是：</strong>事务添加了排它锁，不代表其他事务不能无锁读取该数据（无锁可以读取添加排它锁的数据）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 无锁</span><br><span class="line">&gt;select ... from ...;</span><br><span class="line"></span><br><span class="line">- 共享锁</span><br><span class="line">&gt;select ... from ... lock in share mode;</span><br><span class="line"></span><br><span class="line">- 排它锁</span><br><span class="line">&gt;update ...</span><br><span class="line">&gt;delete ...</span><br><span class="line">&gt;insert ...</span><br><span class="line">&gt;select ... from ... for update</span><br></pre></td></tr></table></figure>

<p><strong>查看锁信息：</strong><br>show status like ‘innodb_row_lock%’;</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Innodb_row_lock_current_waits</td>
<td>当前正在等待锁定的数量</td>
</tr>
<tr>
<td>Innodb_row_lock_time</td>
<td>从系统启动到现在锁定总时间长度</td>
</tr>
<tr>
<td>Innodb_row_lock_time_avg</td>
<td>每次等待所花平均时间</td>
</tr>
<tr>
<td>Innodb_row_lock_time_max</td>
<td>从系统启动到现在等待最长的一次所花的时间</td>
</tr>
<tr>
<td>Innodb_row_lock_waits</td>
<td>系统启动后到现在总共等待的次数</td>
</tr>
</tbody></table>
 <br>
#二、MVCC快照
## 2.1 概念
MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法。
MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

<h2 id="2-2-流程"><a href="#2-2-流程" class="headerlink" title="2.2 流程"></a>2.2 流程</h2><ol>
<li>当修改或删除记录时，会插入一条新记录并指向前一个版本的记录，并标记该记录的操作类型和事务id。</li>
<li>当开启事务并查询表时，会为该事务保存一个快照read-view，保存了当前还未提交的事务id的列表和最大的事务id。</li>
<li>如果是可重复度，那么该事务再次读取数据时会根据保存的read-view，去undo日志查找对其可见的版本列并返回。</li>
<li>如果查找到的最新记录的事务id在read-view的事务id列表中，那么根据指针查找上一版本的记录，直到找到对其可见的记录。</li>
</ol>
<p><img src="/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CMVCC%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.assets%5C3c9a91a6f8404da59018fd7158b4c269.png" alt="read-view流程图"></p>
<p>例：同时开启两个事务，同时不加锁查询同一条记录，在一个事务中修改记录并提交，记录修改成功，但是在另一个事务中读取该记录发现还是修改前的值，直到提交事务后查询该记录，才能读到修改后的记录；因为该事务中读取记录后会保存快照，事务中再次读取都会读取该快照，直到提交事务。</p>
<p>![image.png](MySQL锁机制和MVCC版本控制.assetse4996f96e743d9a735c971b440180d.png)</p>
<br>
# 三、隔离级别
## 3.1 读问题
- 隔离级别：Read Uncommitted（读取未提交内容），所有事务可以看到其他未提交的事务的执行结果。
- 脏读：事务一读取到的是事务二已修改但未提交的数据，在事务二回滚后事务一读取到的数据成为无效数据；
- 隔离级别：Read Committed（读取已提交内容），所有事物只能看见其他已提交事务的执行结果。
- 不可重复读：事务一读取了一个数据，事务2在事务一期间修改了该数据并提交，事务一再次读取这个数据时发现两次数据不一样；
- 隔离级别：Repeatable Read（可重复读），MySQL默认的隔离级别。一个事务中，所有被读过的行都会加上行锁，直到该事务提交或回滚才释放锁。保证事务中多次读同一行的值相同。（添加行锁、间隙锁或表锁）
- 幻读：事务一读取某个范围数据时，事务二在该范围内插入了新数据，事务一再次读取该范围记录时，发现记录数改变，产生幻读。
- 隔离级别：Serializable（可串行化），每个读的数据行上加共享锁，可能造成大量的超时现象和锁竞争。（添加表锁）

<h3 id="3-1-1-隔离级别的实现"><a href="#3-1-1-隔离级别的实现" class="headerlink" title="3.1.1 隔离级别的实现"></a>3.1.1 隔离级别的实现</h3><p>通过锁实现了读未提交和串行化；通过锁配合MVCC实现了读已提交和可重复读。</p>
<h4 id="3-1-1-1-锁机制"><a href="#3-1-1-1-锁机制" class="headerlink" title="3.1.1.1 锁机制"></a>3.1.1.1 锁机制</h4><p>读未提交：读数据时不加锁；<br>读已提交：读数据加共享锁，但是读完就释放锁而不是等到事务结束；<br>可重复读：读数据时添加共享行锁，事务结束释放锁；<br>可串行化：读数据时添加共享表锁，事务结束释放锁。</p>
<h4 id="3-1-1-2-MVCC机制（MySQL主要使用快照保证隔离级别）"><a href="#3-1-1-2-MVCC机制（MySQL主要使用快照保证隔离级别）" class="headerlink" title="3.1.1.2 MVCC机制（MySQL主要使用快照保证隔离级别）"></a>3.1.1.2 MVCC机制（MySQL主要使用快照保证隔离级别）</h4><p>MVCC机制生成一个数据快照，并用这个快照来提供一定级别的一致性的读取，也成为了多版本数据控制。MVCC实现的是普通读取不加锁，并且读写分离，保证了读写并发。</p>
<ul>
<li>实际就是CAS版本控制和读写分离</li>
<li>主要作用读已提交和可重复读</li>
</ul>
<h2 id="3-2-写问题"><a href="#3-2-写问题" class="headerlink" title="3.2 写问题"></a>3.2 写问题</h2><p>脏写(丢失更新)：事务一和事务二读取到数据后进行修改，最后提交的事务覆盖了之前提交的事务，造成丢失更新。</p>
<p><strong>写问题解决方案</strong></p>
<ul>
<li>悲观锁：串行操作。读取数据时添加排他写锁(for update)，其他事务读取时阻塞，等到该事务提交时才允许其他事务进行读写。如果不加for upfate会因为没有加锁和MVCC快照，可以同时读取数据导致数据覆盖丢失更新。</li>
<li>乐观锁：通过版本号进行控制，进入事务后首先获取版本号，提交事务前再次读取版本号进行比较，如果版本号一致，则进行提交，且将版本号加一；如果版本号不一致，则放弃操作。<br>update user set name &#x3D; ‘www’ where id &#x3D; 1 and version &#x3D; 1;</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">CJ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/06/MySQL/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CMVCC%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">http://example.com/2023/05/06/MySQL/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8CMVCC%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/06/MySQL/MySQL%E9%94%81%E5%86%B2%E7%AA%81%E6%8E%92%E6%9F%A5/" title="MySQL锁冲突排查"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL锁冲突排查</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/06/JVM/JVM%E5%9F%BA%E7%A1%80%EF%BC%88%E5%BE%85%E7%BB%AD%EF%BC%89/" title="JVM基础（待续）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM基础（待续）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CJ</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">419</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%94%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">1.1 锁分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-MySQL%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">1.2 MySQL引擎的锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-MyISAM%E5%BC%95%E6%93%8E"><span class="toc-number">2.1.</span> <span class="toc-text">1.2.1 MyISAM引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.2.1.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">建表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E8%A1%A8%E7%BA%A7%E5%86%99%E9%94%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">MyISAM表级写锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E8%A1%A8%E7%BA%A7%E8%AF%BB%E9%94%81"><span class="toc-number">2.1.4.</span> <span class="toc-text">MyISAM表级读锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-3-MyISAM%E8%A1%A8%E7%BA%A7%E9%94%81%E7%AB%9E%E4%BA%89%E6%83%85%E5%86%B5"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.2.1.3 MyISAM表级锁竞争情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-4-%E5%B9%B6%E5%8F%91%E6%8F%92%E5%85%A5"><span class="toc-number">2.1.6.</span> <span class="toc-text">1.2.1.4 并发插入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-5-%E9%94%81%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">1.2.1.5 锁调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-2-%E6%B5%8B%E8%AF%95%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.2.2.2 测试行级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">建表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E8%A1%A8%E7%BA%A7%E5%86%99%E9%94%81%EF%BC%88%E5%AF%B9%E9%9D%9E%E7%B4%A2%E5%BC%95%E5%88%97%E5%8A%A0%E8%A1%8C%E7%BA%A7%E5%86%99%E9%94%81%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">InnoDB表级写锁（对非索引列加行级写锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E8%A1%8C%E7%BA%A7%E5%86%99%E9%94%81%EF%BC%88%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E5%8A%A0%E8%A1%8C%E7%BA%A7%E5%86%99%E9%94%81%EF%BC%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">InnoDB行级写锁（对索引列加行级写锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E9%94%81%E4%BD%8F%E7%9B%B8%E5%90%8C%E8%A1%8C"><span class="toc-number">2.2.5.</span> <span class="toc-text">InnoDB普通索引锁住相同行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-number">2.2.6.</span> <span class="toc-text">结论：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-3-InnoDB%E9%97%B4%E9%9A%99%E9%94%81%E5%92%8CNext-Key%E9%94%81"><span class="toc-number">2.2.7.</span> <span class="toc-text">1.2.2.3 InnoDB间隙锁和Next-Key锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8-2"><span class="toc-number">2.2.8.</span> <span class="toc-text">建表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%8D%95%E8%A1%8C%E5%8A%A0%E9%94%81"><span class="toc-number">2.2.9.</span> <span class="toc-text">为非唯一索引单行加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%8D%95%E8%A1%8C%E5%8A%A0%E9%94%81"><span class="toc-number">2.2.10.</span> <span class="toc-text">为唯一索引单行加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E5%8A%A0%E9%94%81"><span class="toc-number">2.2.11.</span> <span class="toc-text">为非唯一索引范围加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%A3%80%E7%B4%A2%E6%9D%A1%E4%BB%B6%E6%98%AF%E5%90%A6%E4%BC%9A%E5%8A%A0%E4%B8%8A%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%9F"><span class="toc-number">2.2.12.</span> <span class="toc-text">使用不存在的检索条件是否会加上间隙锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.13.</span> <span class="toc-text">死锁的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E6%98%BE%E7%A4%BA%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.3.</span> <span class="toc-text">1.3.1 显示事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.4.</span> <span class="toc-text">1.3.2 隐式事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">2.2 流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.1 隔离级别的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-1-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1.1 锁机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-2-MVCC%E6%9C%BA%E5%88%B6%EF%BC%88MySQL%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BF%AB%E7%85%A7%E4%BF%9D%E8%AF%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.1.2 MVCC机制（MySQL主要使用快照保证隔离级别）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%86%99%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">3.2 写问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/MySQL/%E6%B3%A8%E8%A7%A3@Select%E5%92%8C@Insert/" title="注解@Select和@Insert">注解@Select和@Insert</a><time datetime="2023-05-06T05:48:28.906Z" title="发表于 2023-05-06 13:48:28">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B3%A8%E8%A7%A3@EnableAutoConfiguration/" title="注解@EnableAutoConfiguration">注解@EnableAutoConfiguration</a><time datetime="2023-05-06T05:48:06.027Z" title="发表于 2023-05-06 13:48:06">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%A6%BB%E7%BA%BF/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E6%A1%86%E6%9E%B6/" title="大数据集群监控框架">大数据集群监控框架</a><time datetime="2023-05-06T05:42:56.298Z" title="发表于 2023-05-06 13:42:56">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E9%AB%98%E5%B9%B6%E5%8F%91/HashMap%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%8AConcurrentHashMap%E5%8E%9F%E7%90%86/" title="HashMap并发问题及ConcurrentHashMap原理">HashMap并发问题及ConcurrentHashMap原理</a><time datetime="2023-05-06T05:31:21.103Z" title="发表于 2023-05-06 13:31:21">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E9%AB%98%E5%B9%B6%E5%8F%91/Stream%E5%8E%9F%E7%90%86/" title="Stream原理">Stream原理</a><time datetime="2023-05-06T05:31:21.103Z" title="发表于 2023-05-06 13:31:21">2023-05-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By CJ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>